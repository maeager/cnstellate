// parameters_TV_Notch.hoc
// Cochlear Nucleus network model: parameters file
// based on parameters_odour_baseline.hoc by Andrew Davison
// Michael Eager, University of Melbourne

nchannels       = 100      // Total number of frequency channels
nTSperchannel   = 0   // number of TS cells in each freq channel
numTS   = nchannels*nTSperchannel   // total number of TS cells
nTVperchannel   = 1   // number of TV cells in each freq channel
numTV   = nchannels*nTVperchannel   // total number of TV cells
nDSperchannel   = 1   // number of DS cells in each freq channel
numDS   = nchannels*nDSperchannel   // total number of DS cells
nGperchannel   = 1   // number of Golgi cells in each freq channel
numG   = nchannels*nGperchannel   // total number of Golgi cells
HSRsperchannel  =   40
MSRsperchannel  =   0
LSRsperchannel  =   20
seed        = 0         // seed for random number generator
thresh      = -10       // mV   // threshold for detecting spikes


strdef fileroot
sprint(fileroot,"TV_Notch") // root for output filenames

inputnumber = 1		// fixed input file
stimtype    = 8		// Notch noise (White noise filtered with stop-band filter)
tstop       = 80        // ms   total simulation time
ttrans       = 10       // ms  	// when calculating statistics, ignore
            			// spikes occuring before this time
cvode.active(0)
dt        = 0.05   	//ms  cannot be any higher than 0.1
steps_per_ms = 10
setdt()
celsius = 37
secondorder=2		//Crank-Nicholson Integration method 


//Optimisation parameters
print "Optimisation parameters for TV Notch"
NPARAMS=8
objref pvec,fvec,pvec_ranges,pvec_name,pvec_factor
pvec = new Vector(NPARAMS) //contains the parameters to be fitted
pvec_ranges= new Matrix(NPARAMS,2) // (min,max) pairs for each param
pvec_name = new List() //names of parameters in String list
pvec_factor = new Vector(NPARAMS,1)

  //Names                                               //Initial values	
pvec_name.append(new String("param.w.x[ds][tv]"))	pvec.x[0] = 0.0017	 
pvec_name.append(new String("param.n.x[ds][tv]"))	pvec.x[1] = 20		
pvec_name.append(new String("param.w.x[hsr][tv]"))	pvec.x[2] = 0.0013	
pvec_name.append(new String("param.n.x[hsr][tv]"))	pvec.x[3] = 8		
pvec_name.append(new String("param.w.x[lsr][tv]"))	pvec.x[4] = 0.0019	
pvec_name.append(new String("param.n.x[lsr][tv]"))	pvec.x[5] = 12		
pvec_name.append(new String("param.s.x[lsr][tv]"))	pvec.x[6] = 0.8	
pvec_name.append(new String("param.offset.x[lsr][tv]"))	pvec.x[7] = 2.1

//mul factor
 for i=0,NPARAMS-1 pvec_factor.x[i] = 1	
//min
 for i=0,NPARAMS-1 pvec_ranges.x[i][0]= 0.000001
//max
 for i=0,NPARAMS-1 pvec_ranges.x[i][1]= 0.03

// cmd is a strdef variable that should be used in local routines and not passed across procedures
proc set_pvec(){local pp
    for pp=0,NPARAMS-1 {
        sprint(cmd,"pvec.x[%d] = %s / pvec_factor.x[%d]\n",pp,pvec_name.object(pp).s,pp)
        execute1(cmd)
    }
}

// Reiss and Young Type 2 units
// CF=12.5kHz, spon rate is zero
  objref tempmat
  objref type2_1oct_sweep[2],type2_halfoct_sweep[2]
  
  //"TV_notch/Reiss_Fig9_E_1oct.png.dat" //22dB notch, falling edge 1 oct
  //"TV_notch/Reiss_Fig9_C_halfoct.png.dat" //rising edge 1/2 oct
  //"TV_notch/Reiss_Fig10_Bii_HalfOctMax.png.dat"
  //"TV_notch/Reiss_Fig10_Bi_Max1oct.png.dat"

  //Mean data for one octaveand half octave sweeps (22dB re
  file.ropen("TV_notch/Reiss_Fig10_Bii_HalfOctMean.png.dat")
     tempmat = new Matrix()
     tempmat.scanf(file) //data is 24 rows
     type2_halfoct_sweep[0] = tempmat.getcol(0)
     type2_halfoct_sweep[1] = tempmat.getcol(1)
  file.close()
  file.ropen("TV_notch/Reiss_Fig10_Bi_Mean1oct.png.dat")
     tempmat = new Matrix()
     tempmat.scanf(file) //data is 29 rows
     // centre point is at 25th row
     type2_1oct_sweep[0] = tempmat.getcol(0)
     type2_1oct_sweep[1] = tempmat.getcol(1)
  file.close()

// Convert type2_1oct_sweep and type2_halfoct_sweep to EXPECTED population response to notch 
  objref expected_notch[2]
halfoct_compress=1
halfoct_shift = 1
oct_compress=1
oct_shift = 1
  proc overlapsweeps(){local ii //convert single unit notch sweep to population response (tested in Octave)
  objref expected_notch[2]
      for ii=0,1  {expected_notch[ii] = new Vector()    }
    //x1 =dlmread("./TV_notch/Reiss_Fig10_Bii_HalfOctMean.png.dat"," ",2,0)
    //x2 =dlmread("./TV_notch/Reiss_Fig10_Bi_Mean1oct.png.dat"," ",2,0)
    // plot([0.5-x1(1:9,1)' 1-x2(15:end,1)' ],[x1(1:9,3)' x2(15:end,3)'],'g+-') // 2nd element is empty
    for ii=0,9{
	expected_notch[0].append((halfoct_shift - type2_halfoct_sweep[0].x[ii])/halfoct_compress)    //flip around rising edge
	expected_notch[1].append(type2_halfoct_sweep[1].x[ii])
      }
    for ii=14, type2_1oct_sweep[0].size()-1 {
	expected_notch[0].append((oct_shift - type2_1oct_sweep[0].x[ii])/oct_compress)    //flip around falling edge
	expected_notch[1].append(type2_1oct_sweep[1].x[ii])
      }
     
  }
  overlapsweeps()


  //Convert Octaves to Frequency (Depends on centre point)
  func oct2freq1(){local ratio //Standard Musical Octave Calculation,  $1 centre freq, $2 octave factor
      ratio = 2.0^($2 )
      return $1*ratio
  }

  func oct2freq2(){local ratio //Standard Acoutic Octave Calculation,  $1 centre freq, $2 octave factor
      ratio = 10.0^( 0.3*$2 )
      return $1*ratio
  }







  /* Original notch sweep
  half octave 10 kHz centre
  start rising edge one octave below -> 2.5kHz notch (2.5-5k)
      half oct below-> (5k-7.5k)
      on BF -> (7.5-10k)
      1/2 oct above -> 
  */
