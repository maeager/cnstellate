/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/*  par_experiment_TStellate2
 *  Experimental setup for second TStellate optimisation 
 *
 *    cnstellate was written as part of my PhD at the University of Melbourne 
 *   
 *    Copyright © 2012 Michael Eager, (mick.eager@gmail.com)
 *
 *    This file is part of cnstellate.
 * 
 *    This is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
 */


// CS and CT data were from Long-Evans and Hooded Wistar rats at RVEEH
// reported in \citep{PaoliniClareyEtAl:2005}


//   The cell’s rate-level function was then determined by presenting 50-ms CF
//  tone bursts (5 ms rise–fall time; 25–50 repetitions; 10 Hz repetition
//  frequency) in 5- or 10-dB steps from subthreshold sound pressure
//  levels (SPLs) to SPLs that produced discharge rate saturation. If
//  possible, frequency response areas were then determined by present-
//  ing tones at non-CF frequencies over a range of SPLs.
//     Acoustic stimuli were synthesized digitally and generated by a
//  Beyer DT48 transducer (Beyerdynamic, Farmingdale, NY, USA),
//  which was positioned at the end of a hollow ear bar and controlled
//  using a Tucker-Davis signal generator (Tucker-Davis Technologies,


// Issues with simulated model and experimental data:

// Mean RMP and AP in CS/CT rat neurons Paolini et al 2004:
// average resting potentials (-60.9 ± 1.4 mV), AP heights
// (39.8 ± 1.9 mV), and CFs (9.1 ± 1.0 kHz), OC neurons had
// significantly higher depolarization and AP thresholds than CS/T
// neurons. Specifically, the minimal SPLs that evoked depolar-
// ization in CS/T and OC neurons were 31.7 ± 2.9 and 45.6 ± 2.7
// dB, respectively (t25 = 3.02, P < 0.05), and the minimal SPLs
// that evoked AP generation were 41.8 ± 3.8 and 56.6 ± 2.2 dB,
// respectively (t25 = 2.5, P < 0.05).

TSexemplar_RMP = -60.9
TSexemplar_SPL_thresh = 40
TSexemplar_CF = 9100


//  Differences in the extent of hyperpolarization in
// the identified stellate cell groups can not be attributed to differences in
// RMP because there was no significant difference in this measure
// between groups (F3,40 1⁄4 0.2, P > 0.05). The mean RMP (± SEM) for
// OC, CT1, CT2 and CS cells was: -61.9 ± 1.7, -60.2 ± 1.9, -59.0 ± 1.9
// and -58.7 ± 2.8 mV, respectively.

func SetChopperRMP(){
	if ($1 == 0) {
		return -58.7
	} else if ($1 == 1) {
		return -60.2
	}else if ($1 == 2 ) {
		return -59.0
	}
	
	print "SetChopperRMP: Using default TS RMP"
	return TSexemplar_RMP	
}



// CV classification (Paolini et al 2004,2005):
// Young et al. 1988). This measure differentiates between two chopper
// subtypes, both of which are recorded from T stellate cells. Neurons
// with low, consistent CV values (< 0.2) were classified as CS, while CT
// neurons were those with an initial, low CV (< 0.2) that increased
// during the tone (0.2 < CV < 0.5). Contour plots derived from the
// average intracellular traces over 25 stimulus repetitions were used to
// examine the relationship between stimulus SPL and membrane po-
// tential during CF tone presentation. 


delay					= 0.02
dur						= 0.0475 // Actual duration minus half ramplength
ramplngth				= 0.005 
dutycycle				= 0.8        // get an extra 40msec post-tone
cfhi					= 40000
cflo					= 200
srate					= 100000      // 500k is no longer needed
stimtdres				= 1/srate
sg_rate					= 50000
sg_tdres				= 1/sg_rate
tstop					= 110
ANmodel					= 6
species					= 2 //Rat
audiogram_file			= "rat_bruce_audiogram.dat"
reps					= 25
usesavedfilterbanks		= 1


RefreshCF()
GetAudiogramData()



// Reference and test comparison vectors: These objects are lists with three
// pointers to vectors (each with only 4 members).  The first object is 20 dB re
// threshold, second 30 dB, and third 40 dB.
// The IV vectors contain the onset ratio, the adaptation shift, the offset shift  (and the RMP although this is not compared).
// The CV vectors contain the CV calculations in 10 ms intervals in the stimulus  i.e.  0-10, 10-20, 20-30, and 30-40.
// The weight vectors are used to eliminate unused data and emphasise important comparisons.
objref IV_reference,CV_reference,IV_weight,CV_weight


//temporary variables and objects
objref tempmat, ivdata[2]
objref chopperIVgr,chopperCVgr
objref CV_sustained, CV_transient1, CV_transient2, CV_data
objref CVdata_CS, CVlevel_CS


strdef datestr,grlbl
objref errorvec,tempcf,indcf,gr
objref refvec,ref,test,weightvec
gr = new Graph()

ref_shift=0
test_shift=0
plot_variables=0

// retain IV traces and spikes between simulations at each level
objref TSIVList,TSspikeList




proc SetupChopperCV(){local nrow,ncol
	nrow					= 5
	ncol					= 3
	
	
	objref CV_sustained, CV_transient1, CV_transient2
	CV_transient2			= new Matrix()
	CV_transient1			= new Matrix()
	CV_sustained			= new Matrix()
	
	file = new File()
	file.ropen("TStellate/PaoliniBalancedInh-Fig2.png.dat")
	if(file.isopen()){
		CV_transient2.scanf(file,nrow, ncol)
		CV_transient1.scanf(file,nrow, ncol)
		CV_sustained.scanf(file,nrow, ncol)
		file.close()
	} else {
		print "Error reading TStellate/PaoliniBalancedInh-Fig2.png.dat"
	}
	
	// CV at 3 levels for CS unit in Figure 3C (20,40,50 dB re Thresh)
	file.ropen("TStellate/Paolini2005_Fig3C_CVdata.dat")
	if(file.isopen()){
		CVdata_CS = new Matrix()
		CVdata_CS.scanf(file,5, 4)
		file.close()
		CVlevel_CS = new Vector()
		//SPL values in Figure 3,  re threshold
		CVlevel_CS.append(20,40,50)
	} else {
		print "Error reading CV data TStellate/Paolini2005_Fig3C_CVdata.dat"
	}
	
}

SetupChopperCV()

// MP Statistics -- Paolini, Clarey et al 2005 --
//     The following variables were measured from the average
//  intracellular profile (25 stimulus repetitions) at 30 dB (± 5 dB) above
//  the SPL that evoked voltage depolarization from the resting membrane
//   potential (RMP): (i) a measure of the level of initial depolarization was
//  given by the ratio of the depolarization occurring 5–10 ms after tone
//  onset to the average amplitude drop to sustained levels occurring 20–
//   30 ms after tone onset; (ii) a measure of the adaptation of sustained
//  depolarization during tone presentation was given by the difference in
//  depolarization amplitude at 20 ms and 50 ms after stimulus onset; (iii)
//  a measure of post-tone hyperpolarization was given by the change in
//  voltage, relative to RMP, 60 ms after stimulus onset (i.e. 10 ms after
//  tone offset). Membrane potential levels from traces calculated at
//  specific time points for variables 2 and 3 (i.e. 20, 50 and 60 ms) were
//  found by averaging the membrane potential over a 1-ms period (i.e.
//  20–21, 50–51 and 60–61 ms). Included in this sample are four
//  neurons whose responses to tones have been described previously
//  (Paolini & Clark, 1999; cell #: 98-280-003, 95-232-003, 98-257-002,
//  96-249-012). The intracellular response profile of all neurons reported
//  in this study was distinct from that of bushy cells (Paolini et al., 1997;
//  Paolini & Clark, 1999).



//Membrane potential adaptation and hyperpolarisation
// data from Figure 6 in Paolini et al. 2005
// MP*_data will be used in the optimation routine
// Average of 10 CT1, 4 CT2  units
// Note: no CS unit average only single unit at levels other than 30 dB re threshold 
objref MPadaptation_CS, MPadaptation_CT1, MPadaptation_CT2, MPadaptation_data
objref MPhyper_CS, MPhyper_CT1, MPhyper_CT2, MPhyper_data, MPlevel_re_thresh

proc SetupChopperMP(){local nrow,ncol
	objref MPadaptation_CS, MPadaptation_CT1, MPadaptation_CT2, MPadaptation_data
	objref MPhyper_CS, MPhyper_CT1, MPhyper_CT2, MPhyper_data
	
	nrow = 4 // four SPL levels
	ncol = 3 // SPL, Adaptation or Offset difference mean , standard deviation
	
	MPadaptation_CS = new Matrix()
	MPadaptation_CT1 = new Matrix()
	MPadaptation_CT2 = new Matrix()
	
	MPhyper_CS = new Matrix()
	MPhyper_CT1 = new Matrix()
	MPhyper_CT2 = new Matrix()
	MPlevel_re_thresh = new Vector()
	MPlevel_re_thresh.append(10,20,30,40)
	
	// CT 1 & 2 adaptation 
	file = new File()
 	file.ropen("TStellate/Fig6A.dat")
	if(file.isopen()){
		MPadaptation_CT2.scanf(file,nrow, ncol)
		MPadaptation_CT1.scanf(file,nrow, ncol)
		MPadaptation_CS = new Matrix(nrow,ncol)
		MPadaptation_CS.zero()
		file.close()
	} else {
		print "Error reading MP data"
	}
	
	//CT 1 & 2 hyperpolarisation
	file.ropen("TStellate/Fig6B.dat")
	if(file.isopen()){
		MPhyper_CT2.scanf(file,nrow, ncol)
		MPhyper_CT1.scanf(file,nrow, ncol)
		file.close()
	} else {
		print "Error reading MP data Fig6B.dat"
	}
	
	// CS unit 01-859-013
	// Figure 3, Paolini et al., 2005
	// Hyperpolarisation MPt60 - RMP
	file.ropen("./TStellate/PaoliniBalancedInh_Fig3_Offset.dat")
	if(file.isopen()){
		MPhyper_CS = new Matrix()
		MPhyper_CS.scanf(file,4, 4)
		file.close()
	} else {
		print "Error reading MP data PaoliniBalancedInh-Fig3_Offset.dat"
	}
	
	
}

SetupChopperMP()



proc CalcIVMeasures(){
	
    onset_depol = $o1.mean(ivdata[0].indwhere(">=",5.0), ivdata[0].indwhere(">=",10.0))
    middle_depol = $o1.mean( ivdata[0].indwhere(">=",20), ivdata[0].indwhere(">=",30))
	
    onset_ratio = onset_depol / middle_depol
	
    v20_depol = $o1.mean( ivdata[0].indwhere(">=",20) - 1, ivdata[0].indwhere(">=",21))
    v50_depol = $o1.mean( ivdata[0].indwhere(">=",50) -1, ivdata[0].indwhere(">=",51))
    adaptation_ratio = v20_depol - v50_depol
  	
    resting_value  = $o1.mean(0 , ivdata[0].indwhere(">",0))
    v60_depol = $o1.mean(ivdata[0].indwhere(">=",60) - 1, ivdata[0].indwhere(">=",61))
    offset_hyperpol = resting_value - v60_depol
	
    print "resting membrane potential              ", resting_value
    print "level of initial depolarization         ", onset_depol
    print "onset ratio                             ", onset_ratio
	
    print "adaptation of sustained depolarization  ", adaptation_ratio
    print "post-tone hyperpolarization             ", offset_hyperpol
	
}

objref IV_temp,IV_reference,CV_reference,CV_temp,ref_IVvec
objref IV_weight,CV_weight // set the RMS error weighting, set to zero if no reference data

default_CV_weight=100
sustained_transient_chopper=0


proc CS_data() {local points
	//chopper sustained
	// unit 01-864-004  CF 11.7kHz  AP threshold 10 dB
	//CV (10ms segs) always below 0.2 for 45, 65, and 75 dB
	// rate saturation at 75 dB
	// threshold 10dB
	//spl      = 40   //30 dB above depolarisation threshold
	//tonefreq = 11700 //Hz, characteristic frequency

 spl = TSexemplar_SPL_thresh
 tonefreq = TSexemplar_CF

	
	whichcell = FindInd(tonefreq)  //get CF index close to 3.9kHz
	print "CS data CF ", tonefreq, "(Hz), location ", whichcell
	
	objref tempmat, ivdata[2]
	ivdata[0] = new Vector()
	ivdata[1] = new Vector()
	
	//Get iv trace from Figure 1A (Paolini et al 2005)
	// spl=40 dB in figure
	file.ropen("TStellate/CS-01-864-004.png.dat")
	tempmat = new Matrix()
	tempmat.scanf(file)
	ivdata[0] = tempmat.getcol(0) //time
	ivdata[1] = tempmat.getcol(1) //voltage (mV)
	file.close()
	chopperIVgr =  new Graph()
	ivdata[1].plot(chopperIVgr,ivdata[0])
	chopperIVgr.exec_menu("View = plot")
	sprint(fileroot,"TStellate2_CS")    // root for output filenames
	sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	

	
	IV_reference = new List()
	IV_weight = new List()
	//10 dB re thresh
	//IV_temp = new Vector(4,0)	
	//IV_reference.append(IV_temp) //No data
	//IV_weight.append(IV_temp)
	
	//20 dB re thresh
	IV_temp = new Vector(4,0)
	IV_temp.x[2] = MPhyper_CS.x[0][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CS.x[0][2] //RMP
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison
	IV_weight.append(IV_temp)
			
	//30 dB re thresh  (use actual trace in Figure 1)
	IV_temp = new Vector()
	CalcIVMeasures(ivdata[1])
	IV_temp.append(onset_ratio,adaptation_ratio ,offset_hyperpol,resting_value)	 
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,1)
	IV_temp.x[3]=0  // ignore RMP
	IV_weight.append(IV_temp) //all data available
	
	
	
	//40 dB re thresh
	IV_temp = new Vector(4)	
	IV_reference.append(IV_temp)
	IV_temp.x[2] = MPhyper_CS.x[2][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CS.x[2][2] //RMP
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison	
	IV_weight.append(IV_temp)
	
	
	SetupChopperCV()
	CV_reference = new List()
	CV_weight = new List()
	
	//10 dB re thresh
	//CV_temp = new Vector()	
	//CV_reference.append(CV_temp) //No data
		
	//20 dB re thresh  (remove the last elementin CVdata_CS)
	CV_reference.append(CVdata_CS.getcol(1).remove(4))
	CV_temp = new Vector(4,default_CV_weight)
	CV_weight.append(CV_temp)

	
	//30 dB - Average data in Figure 2 
	CV_temp = CV_sustained.getcol(1).c
	CV_reference.append(CV_temp.remove(4))
	CV_temp = new Vector(4,default_CV_weight*2)
	CV_weight.append(CV_temp)

	
	//40 dB re thresh
	CV_temp = new Matrix()
	CV_reference.append(CVdata_CS.getcol(2).remove(4))
	CV_temp = new Vector(4,default_CV_weight)
	CV_weight.append(CV_temp)
	
	sustained_transient_chopper=0
	
}
proc Test_IVCV_reference_data(){local ii
	for ii=0,2 {
		print "ii  ", ii	
		CV_reference.object(ii).printf
		CV_weight.object(ii).printf
		print ""  
		IV_reference.object(ii).printf
		IV_weight.object(ii).printf
	}
}

proc CT1_data() {local points localobj temp
	
	// chopper transient 1
	// unit 01-857-007 \citep{PaoliniClareyEtAl:2005}
	// CV first 10ms <0.2, then moves above 0.2
	// this unit's depolarisation threshold  55 dB
	// average CT threshold for depolarization
	// and AP generation of 47.2 ± 2.5 and 57.4 ± 2.2 dB SPL
	
	//spl      = 85   //30 dB above depolarisation threshold
	//tonefreq = 8200 //Hz, characteristic frequency
	 spl = TSexemplar_SPL_thresh
	 tonefreq = TSexemplar_CF

	
	whichcell = FindInd(tonefreq)  //get CF index close to 8.2kHz
	print "CT1 data CF ", tonefreq, "(Hz), location ", whichcell
	sprint(fileroot,"TStellate2_CT1")    // root for output filenames 	
	sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	
	file.ropen("TStellate/CT1-01-857-007.png.dat")
	objref tempmat, ivdata[2]
	ivdata[0] = new Vector()
	ivdata[1] = new Vector()
	tempmat = new Matrix() //points, 2)
	tempmat.scanf(file)
	ivdata[0] = tempmat.getcol(0) //time
	ivdata[1] = tempmat.getcol(1) //voltage (mV)
	file.close()
	chopperIVgr =  new Graph()
	ivdata[1].plot(chopperIVgr,ivdata[0])
	chopperIVgr.exec_menu("View = plot")

	
	
	IV_reference = new List()
	IV_weight = new List()
	//10 dB re thresh
	//IV_temp = new Vector(4,0)	
	//IV_reference.append(IV_temp) //No data
	//IV_weight.append(IV_temp)
	
	//20 dB re thresh
	IV_temp = new Vector(4,0)
	IV_temp.x[1] = MPadaptation_CT1.x[1][1]
	IV_temp.x[2] = MPhyper_CT1.x[1][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT1.x[1][2] //s.e.
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  //  
	IV_weight.append(IV_temp)
			
	//30 dB re thresh  (use actual trace in Figure 1)
	IV_temp = new Vector()
	CalcIVMeasures(ivdata[1])
	IV_temp.append(onset_ratio,adaptation_ratio ,offset_hyperpol,resting_value)	 
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,1)
	IV_temp.x[3]=0  // ignore RMP
	IV_weight.append(IV_temp) //all data available
	
	
	
	//40 dB re thresh
	IV_temp = new Vector(4)	
	IV_reference.append(IV_temp)
	IV_temp.x[1] = MPadaptation_CT1.x[1][1]
	IV_temp.x[2] = MPhyper_CT1.x[2][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT1.x[2][2] //s.e. of hyperpolarisation
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison	
	IV_weight.append(IV_temp)
	

	
	//CV
	SetupChopperCV()
	CV_reference = new List()
	CV_weight = new List()
	
	CV_temp = CV_transient1.getcol(1).c	
	CV_temp.remove(4)

	//10 dB re thresh
	//CV_temp = new Vector()	
	//CV_reference.append(CV_temp) //No data
		
	//20 dB re thresh  (remove the last elementin CVdata_CS)
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)

	
	//30 dB - Average data in Figure 2 
	CV_reference.append(CV_temp)	
	temp = new Vector(4,default_CV_weight*2)
	CV_weight.append(temp)

	
	//40 dB re thresh
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)
	
	sustained_transient_chopper=1
		
}

proc CT2_data() {local points localobj temp
	
	//chopper transient type 2
	// unit 01-305-014 \citep{PaoliniClareyEtAl:2005}
	//CV (10ms segs) first 10m below 0.2, then rises above 0.3
	// rate saturation at 5 dB
	//spl      = 35   //30 dB above depolarisation threshold
	//tonefreq = 12400 //Hz
 spl = TSexemplar_SPL_thresh
 tonefreq = TSexemplar_CF
	
	whichcell = FindInd(tonefreq)  //get CF index close to 12.4kHz
	file.ropen("TStellate/CT2-01-305-014.png.dat")
	print "CT2 data CF ", tonefreq, "(Hz), location ", whichcell

	
	objref tempmat, ivdata[2]
	ivdata[0] = new Vector()
	ivdata[1] = new Vector()
	tempmat = new Matrix() //points, 2)
	tempmat.scanf(file)
	ivdata[0] = tempmat.getcol(0) //time
	ivdata[1] = tempmat.getcol(1) //voltage (mV)
	file.close()
	chopperIVgr =  new Graph()
	ivdata[1].plot(chopperIVgr,ivdata[0])
	chopperIVgr.exec_menu("View = plot")
	sprint(fileroot,"TStellate2_CT2")    // root for output filenames
 	sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	
	
	CalcIVMeasures(ivdata[1])
	
	
	
	IV_reference = new List()
	IV_weight = new List()
	//10 dB re thresh
	//IV_temp = new Vector(4,0)	
	//IV_reference.append(IV_temp) //No data
	//IV_weight.append(IV_temp)
	
	//20 dB re thresh
	IV_temp = new Vector(4,0)
	IV_temp.x[1] = MPadaptation_CT2.x[1][1]
	IV_temp.x[2] = MPhyper_CT2.x[1][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT2.x[1][2] //s.e.
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  //  
	IV_weight.append(IV_temp)
			
	//30 dB re thresh  (use actual trace in Figure 1)
	IV_temp = new Vector()
	CalcIVMeasures(ivdata[1])
	IV_temp.append(onset_ratio,adaptation_ratio ,offset_hyperpol,resting_value)	 
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,1)
	IV_temp.x[3]=0  // ignore RMP
	IV_weight.append(IV_temp) //all data available
	
	
	
	//40 dB re thresh
	IV_temp = new Vector(4)	
	IV_reference.append(IV_temp)
	IV_temp.x[1] = MPadaptation_CT2.x[1][1]
	IV_temp.x[2] = MPhyper_CT2.x[2][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT2.x[2][2] //s.e. of hyperpolarisation
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison	
	IV_weight.append(IV_temp)
	

	
	//CV
	SetupChopperCV()
	CV_reference = new List()
	CV_weight = new List()
	
	CV_temp = CV_transient2.getcol(1).c	
	CV_temp.remove(4)

	//10 dB re thresh
	//CV_temp = new Vector()	
	//CV_reference.append(CV_temp) //No data
		
	//20 dB re thresh  (remove the last elementin CVdata_CS)
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)

	
	//30 dB - Average data in Figure 2 
	CV_reference.append(CV_temp)	
	temp = new Vector(4,default_CV_weight*4)
	CV_weight.append(temp)

	
	//40 dB re thresh
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)
	
	sustained_transient_chopper=1
		

	
}


CT1_data()
//RefreshParameters()    //Generate or get stim from file
//ANFilterBankRun()

binwidth=0.5
objref iv,meaniv,psthgr,tstellate_spikes
psthgr = new Graph()

proc RunTStellate(){

	RefreshCF()
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
	//CheckFilterbank()
	SetInputRates()

	
    objref iv,meaniv,tvec
	//ClearSpikes()
    iv = new Vector()
    iv.record(&tstellate[whichcell][0].soma.v(0.5))
    meaniv = new Vector(tstop/dt + 1,0)
    //tstellate[whichcell][0].spikes.resize(0)
	tstellate_spikes = new List()
    for ireps = 0, reps-1 {
        GenSpikes2()
        print ireps
        run()
        //SaveSpikes()
        tstellate_spikes.append(tstellate[whichcell][0].spiketimes.c)
        for i=0,tstop/dt-1{
			if (iv.x[i] > thresh) iv.x[i] = thresh
        }
        meaniv.add(iv)
        iv.mul(0)
    }
    meaniv.div(reps)
    tvec=new Vector(tstop/dt + 1)
    tvec.indgen(dt).add(-stimdelay*1000)
    meaniv.plot(chopperIVgr,tvec)
	
    chopperIVgr.exec_menu("View = plot")
	CalcIVMeasures(ivdata[1])
	CalcIVMeasures(meaniv)
	//psth = tstellate[whichcell][0].spikes.histogram(0,110,binwidth)
	//psth.plot(psthgr,binwidth) psthgr.exec_menu("View = plot")
	PSTHcell(tstellate_spikes,10,1)
}


param.ts_gnabar						= 0.23677
param.ts_gkhtbar					= 0.0189416
param.ts_gleak						= 0.000473539
param.ts_erev						= -60.9
param.ts_ghbar						= 6.20392e-05
param.ts_gkabar						= 0.01539
param.ts_dend_g    = 0.001
param.ts_dend_e    = -65
param.ts_jitter_sd = 0.2
param.dstellate_gleak/=10
param.dstellate_gnabar/=2


proc reset_TStellate(){local ii
    print "updating features for T stellate optimisation routines"
    for ii = 0,nchannels-1 {
		//        if(ii == 20 || ii == 38 || ii == 51){
		sprint(cmd,"tstellate[%d][0].soma.gnabar_rm  = param.ts_gnabar",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.gkhtbar_rm = param.ts_gkhtbar",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.gleak_rm   = param.ts_gleak",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.erev_rm    = param.ts_erev",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.ghbar_rm   = param.ts_ghbar",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.gkabar_ka  = param.ts_gkabar",ii) execute1(cmd)
		
		if (use_ball_stick == 1){
			sprint(cmd,"tstellate[%d][0].dend.g_pas  = param.ts_dend_g",ii) 
			execute1(cmd)
			sprint(cmd,"tstellate[%d][0].dend.e_pas  = param.ts_dend_e",ii) 
			execute1(cmd)
			}
		//        }
	}
}

// Calculate average IV measures  and put them in first three elements in input vector 3 
proc IVMeasures(){local offset
    /// args: 1 time vec, 2 voltage vec, 3 output vec (size=6), 4 offset
	if (numarg() != 4) {
		offset = stimdelay*1000
	} else {
		offset = $4
	}
	offset-=stimdelay*1000
	
	
    onset_depol = $o2.mean($o1.indwhere(">=",5.0), $o1.indwhere(">=",10.0))
    middle_depol = $o2.mean( $o1.indwhere(">=",20), $o1.indwhere(">=",30))
    onset_ratio = onset_depol / middle_depol
	
    v20_depol = $o2.mean( $o1.indwhere(">=",20) - 1, $o1.indwhere(">=",22))
    v50_depol = $o2.mean( $o1.indwhere(">=",50) - 1, $o1.indwhere(">=",52))
    adaptation_ratio = v20_depol - v50_depol
	
    resting_value  = $o2.mean($o1.indwhere(">",-10) , $o1.indwhere(">",0))
    v60_depol  = $o2.mean($o1.indwhere(">=",60) - 1, $o1.indwhere(">=",62))
    offset_hyperpol = resting_value - v60_depol
	
	//     onset_depol = $o2.mean($o1.indwhere(">=",5.0+offset), $o1.indwhere(">=",10.0+offset))
    // middle_depol = $o2.mean( $o1.indwhere(">=",20+offset), $o1.indwhere(">=",30+offset))
    // onset_ratio = onset_depol / middle_depol
	
    // v20_depol = $o2.mean( $o1.indwhere(">=",20+offset) - 1, $o1.indwhere(">=",22+offset))
    // v50_depol = $o2.mean( $o1.indwhere(">=",50+offset) - 1, $o1.indwhere(">=",52+offset))
    // adaptation_ratio = v20_depol - v50_depol
	
    // resting_value  = $o2.mean($o1.indwhere(">",-10) , $o1.indwhere(">",0))
    // v60_depol  = $o2.mean($o1.indwhere(">=",60+offset) - 1, $o1.indwhere(">=",65+offset))
    // offset_hyperpol = resting_value - v60_depol

	
    $o3.x[0] = onset_ratio
    $o3.x[1] = adaptation_ratio
    $o3.x[2] = offset_hyperpol
	print "resting membrane potential              ", resting_value
	print "level of initial depolarization         ", onset_ratio
	print "adaptation of sustained depolarization  ", adaptation_ratio
	print "post-tone hyperpolarization             ", offset_hyperpol
	
}



//mimick connect_CNcells from CochlearNucleus.hoc
proc connect_TS() {local i_chan,i,p,target,source,low,high,range,channel,sourcechannel
	
	objref tstellate[nchannels][nTSperchannel]
	
	for i_chan = 0, nchannels-1 {
		if (nTSperchannel > 0) {
			for j_cell = 0, nTSperchannel-1 {
				if(use_ball_stick==0){
					sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d)",i_chan,j_cell,i_chan,i_chan)
				} else {
					sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d,1)",i_chan,j_cell,i_chan,i_chan)
				}
				execute1(cmd)
			}
		}	
	}	
	
	
	
	print "Connecting cells."
	sprint(filename,"%s.connect",$s1)
	outfile.wopen(filename)
	
	
	objref 	hsr2tsAMPAlist,	lsr2tsAMPAlist,	glg2tsGABAlist,	ds2tsGLYlist,	tv2tsGLYlist,	ts2tsAMPAlist
	
	hsr2tsAMPAlist = new List()
	lsr2tsAMPAlist = new List()
	glg2tsGABAlist = new List()
	ds2tsGLYlist  = new List() 
	tv2tsGLYlist  = new List() 
	ts2tsAMPAlist  = new List()
	
	
	
	if( ( param.n.getval(hsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",hsr,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(hsr,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(hsr,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1 + int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells in sourcechannel
					source = random.discunif(0,HSRsperchannel-1)
					//print "HSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
					sprint(cmd, "tstellate[%d][%d].soma hsr2tsAMPAlist.append( new NetCon( an.HSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(hsr,ts), param.w.getval(hsr,ts)))",channel,target,sourcechannel,source,channel,target)
					execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rHSR->TS === %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rHSR->TS === done ===\n")
	}
	
	if( ( param.n.getval(lsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",lsr,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(lsr,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(lsr,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells
					source = random.discunif(0,LSRsperchannel-1)
					//print "LSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
					sprint(cmd, "tstellate[%d][%d].soma lsr2tsAMPAlist.append( new NetCon( an.LSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ts), param.w.getval(lsr,ts)))",channel,target,sourcechannel,source,channel,target)
					execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rLSR->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rLSR->TS=== done ===\n")
	}
	
	
	print "Connecting CN network cells to TS cells"
	
	
	if( ( param.n.getval(ts,ts) > 0 ) && ( nTSperchannel > 1 ) ){
		outfile.printf("%d %d\n",ts,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(ts,ts)-1{
					//Choose random source from available cells
					source = random.discunif(0,nTSperchannel-1)
					while( source == target)  source = random.repick()  //Don't connect to self
					// print "TS[",channel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					// tscells[channel*numTSperchannel+target].connect_pre(tscells[source], 1, param.delay.getval(ts,ts), param.w.getval(ts,ts))
					sprint(cmd, "tstellate[%d][%d].soma ts2tsAMPAlist.append( new NetCon(&v(0.5), tstellate[%d][%d].AMPA, thresh,param.delay.getval(ts,ts), param.w.getval(ts,ts)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					outfile.printf("%d %d %d %d\n",channel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rTS->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rTS->TS=== done ===\n")
	}
	
	
	if( ( param.n.getval(tv,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nTVperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",tv,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(tv,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(tv,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells
					source = random.discunif(0,nTVperchannel-1)
					// print "TV[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					sprint(cmd, "tuberculoventral[%d][%d].soma tv2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR,  thresh,param.delay.getval(tv,ts), param.w.getval(tv,ts)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rTV->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rTV->TS=== done ===\n")
	}
	
	if( ( param.n.getval(ds,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",ds,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(ds,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(ds,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells
					source = random.discunif(0,nDSperchannel-1)
					// print "DS[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					sprint(cmd, "dstellate[%d][%d].soma ds2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR, thresh,param.delay.getval(ds,ts), param.w.getval(ds,ts)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rDS->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rDS->TS=== done ===\n")
	}
	
	
	if( ( param.n.getval(glg,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nGperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",glg,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(glg,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(glg,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					
					//Choose random source from available cells
					source = random.discunif(0,nGperchannel-1)
					// print "GLG[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					if (LSR2GLG ==1 ) { //Conductance model of golgi
						sprint(cmd, "golgi[%d][%d].soma glg2tsGABAlist.append( new NetCon(&v(0.5),tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
						execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					} else { //filter based model of golgi
						sprint(cmd, "glg2tsGABAlist.append( new NetCon( golgi[%d][%d].sg, tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
						execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
					}
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rGLG->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rGLG->TS=== done ===\n")
	}
	
	
	outfile.close()
	
}

threshold_rate=0
objref penalties

func TStellate2_err( ) {local jj,pp,xtime,error,penalty,sustainedrate,inputresistance,lcount localobj ivtemp,spikelist_temp
	
	penalty=0
	objref penalties
	penalties = new Vector()
	error=0
	//check for bad values
	for pp=0,NPARAMS-1 {
		if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
			return 1e9
		}
	}
	
	//print variables
	print "TStellate_err2 ", $1
	for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])}
	//Set the parameters (see parameters_TStellate.hoc)
	for pp=0,NPARAMS-1 {
		sprint(cmd,"%s = %g * %g ",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
		execute1(cmd)
	}
	flushf()
	// if (plot_variables == 1) {
	//   tgr[0].line($&2[0], $&2[1])
	//   tgr[0].flush()
	//   tgr[1].line($&2[1], $&2[2])
	//   tgr[1].flush()
	//   doNotify()
	//   print $1, $&2[0], $&2[2], $&2[3]
	// }
	
	connect_TS(fileroot)
	RefreshCellParams() //refresh_TStellate()
	jitterdelay(param.delay.x[hsr][ts],param.ts_jitter_sd)

	//Analyse spikes
	doNotify()
	//CNSpikes2()
	
//Stimulus at threshold	
	spl =  TSexemplar_SPL_thresh
	reps=2
	RunTStellate()
	threshold_rate = psth.sum()/reps
	if(threshold_rate > 10) penalties.append( (threshold_rate-10)/100 )
	print "threshold rate", threshold_rate
	//penalty for spikes during tone at threshold
	
	
	objref TSIVList,TSspikeList	
	TSIVList = new List()
	TSspikeList = new List()

	// Calculate fitness
	objref ref_IVvec,weightvec,ref,test
	ref_IVvec = new Vector()
	weightvec = new Vector(7,1)
	ref = new Vector(7,0)
	test = new Vector(7,0)
	

	reps=25		
	for (spl = TSexemplar_SPL_thresh+20; spl<= TSexemplar_SPL_thresh + 40; spl += 10){ 
		RunTStellate()			
		TSIVList.append(meaniv.c)
		TSspikeList.append(tstellate_spikes)
	}
	
		
	for ii=0,2 {
		test_shift = (TSIVList.object(ii).max_ind(stimdelay*1000/dt,(stimdelay*1000 + 20)/dt)/10) - 2.5	
		test = new Vector(4)
		IVMeasures(tvec,TSIVList.object(ii),test,test_shift)
		print "IV test measures "		
		test.printf
		IV_reference.object(ii).printf
		//IV comparison 
		error+=sqrt(IV_reference.object(ii).meansqerr(test,IV_weight.object(ii))) 	
        print "IV comparison ", sqrt(IV_reference.object(ii).meansqerr(test,IV_weight.object(ii))) 	
		
		PSTHcell(TSspikeList.object(ii),10,1)
		
		//Global vector cvISI manipulated by PSTHcell - bad code
		test = new Vector(4)
		test.copy(cvISI, 0, 0, 3, 1, 1)
		
		//CV comparison 
		error+=sqrt(CV_reference.object(ii).meansqerr(test,CV_weight.object(ii))) 	
		print "CV comparison ", sqrt(CV_reference.object(ii).meansqerr(test,CV_weight.object(ii))) 	
		
		
		//Calculate additional penalties
		
		//Penalty: Number of trials counted in CV 
		if(checkedtrials < 0.9*reps) {
			penalties.append( 10)
			print "Checked trials penalty +10 ", checkedtrials 
		}
	//Penalty 1: Sustained rate 
		sustainedrate = psth.sum(2,6)/25
//		if (ii > 1)	{
//			if(sustainedrate < 50) penalties.append( sustainedrate - 50) //penalty for lack of spikes during tone
//		}

        if(psth.sum(8,12)/25 > 10) {
			penalties.append(psth.sum(8,12)/25 - 10) //penalty for too many spikes after tone
			print "After tone spikes ", psth.sum(8,12)/25
		}

		
		//Penalty 3: CV follows criteria for chopper
		//First 10 ms must be strongly regular
		print "CV of test cell"
		cvISI.printf		
		if(cvISI.x[0] > 0.2) 	penalties.append( (cvISI.x[0] - 0.2))
		
		if(cvISI.x[0] > 0.3) penalties.append( 10)
		if (sustained_transient_chopper==0){
			//Sustained model	
			if(cvISI.x[1] > 0.3 || cvISI.x[1] == 0) penalties.append( 10)
			if(cvISI.x[2] > 0.3 || cvISI.x[2] == 0) penalties.append( 10)
			if(cvISI.x[3] > 0.3 || cvISI.x[3] == 0) penalties.append( 10)
		} else {
			//Transient models
			if(cvISI.x[1] > 0.5 || cvISI.x[1] == 0) penalties.append( 10)
			if(cvISI.x[2] > 0.5 || cvISI.x[2] == 0) penalties.append( 10)
			if(cvISI.x[3] > 0.5 || cvISI.x[3] == 0) penalties.append( 10)  
		}
		
				
	}//ii  for loop

	//Penalty 4: Input resistance must be within physiological range
	access tstellate[whichcell][0].soma 
	inputresistance = rn() //Calculate input resistance, see Utilities.hoc   
	if(inputresistance < 30 || inputresistance > 400) penalties.append(100)
	
	print "Penalties size ", penalties.size()
	penalties.printf
	error += penalties.sum()
	
	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
	}
	file.printf("%g\n",error)
	file.close()
	
	doNotify()
	return error
}


proc printprax(){local pp,ii,pp2,cur_reps
	//Output model data with best parameters
	cur_reps = reps
	reps=50
	sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	reps=50
	print error=TStellate2_err(0,&pvec.x[0])
	system("date",datestr)
	sprint(fname,"%s/%s.Fit.dat",fileroot,origfileroot)
	file.wopen(fname)
	if (file.isopen()){
file.printf("# %s Optimisation\n",fileroot)
file.printf("# %s \n",datestr)
for pp=0,NPARAMS-1 {
	file.printf("#%s = %g\t[%g,%g]\n",pvec_name.object(pp).s,pvec.x[pp]*pvec_factor.x[pp],pvec_ranges.x[pp][0],pvec_ranges.x[pp][1])
}
file.printf("# final error=%f\n",error)
//file.printf("# Principle axis matrix\n")
//for pp=0,NPARAMS-1 {
//pval[pp] = new Vector(NPARAMS)
//pval_praxis(pp,&pval[pp].x[0])
//file.printf("#\t")
//for pp2=0,NPARAMS-1 file.printf("%g\t",pval[pp].x[pp2])
//file.printf("\n")
//}
file.printf("# Threshold level %g \n", TSexemplar_SPL_thresh )
file.printf("# Threshold rate %g \n", threshold_rate)
file.printf("# TS exemplar RMP %g\n", TSexemplar_RMP )
file.printf("# TS exemplar CF %g\n",TSexemplar_CF)

file.printf("# Time\t IV @spl=20 (mV)\t IV @spl=30 (mV)\t IV @spl=40 (mV)\n")
for ii=0,tvec.size()-1 {
	file.printf("%.2f\t%.6f\t%.6f\t%.6f\n",tvec.x[ii],TSIVList.object(0).x[ii],TSIVList.object(1).x[ii],TSIVList.object(2).x[ii])
}


for ii=0,2 {
	test_shift = (TSIVList.object(ii).max_ind(stimdelay*1000/dt,(stimdelay*1000 +20)/dt)/10) - 2.5
	test = new Vector(4)
	IVMeasures(tvec,TSIVList.object(ii),test,test_shift)
	
	file.printf("# IV Measures at spl %d\n",TSexemplar_SPL_thresh+ 20+ ii*10 )
	file.printf("# RMP \t%g\t%g \n", IV_reference.object(ii).x[3], test.x[3])
	file.printf("# IVshift\t%g\n", test_shift)
	file.printf("# IVOnset\t%g\t%g\n", IV_reference.object(ii).x[0], test.x[0])
	file.printf("# IVAdaptation\t%g\t%g\n", IV_reference.object(ii).x[1], test.x[1])
	file.printf("# IVOffset\t%g\t%g\n", IV_reference.object(ii).x[2],test.x[2])
	penalty = sqrt(IV_reference.object(ii).meansqerr(test,IV_weight.object(ii)))	
	file.printf("# IV Measures RMS error \t%g\n", penalty)
	
	//IV comparison 
	error+=penalty
		
	PSTHcell(TSspikeList.object(ii),10,1)
	file.printf("#PSTH: Time\t Rate (sp/s)\n")
	for jj=0,psth.size()-1 {
		file.printf("# %d\t%.6f\n",jj,psth.x[jj])
	}
	file.printf("#CV: Time\t CV ()\t\t ISI mean (ms)\t\t ISI sd (ms) \n")
	for jj=0,4 {
		file.printf("# %d\t%.6f\t%.6f\t%.6f\n",jj,cvISI.x[jj], uISI.x[jj],sISI.x[jj])
	}
	test = new Vector(4)
	test.copy(cvISI, 0, 0, 3, 1, 1)
	file.printf("#CV: Time\t CV reference\t\t CV test ()\t Weighting \n")
	for jj=0,test.size()-1 {
		file.printf("# %d\t%.6f\t%.6f\t%.6f\n",jj,test.x[jj], CV_reference.object(ii).x[jj], CV_weight.object(ii).x[jj])
	}
	//IV comparison 
	print error+=sqrt(CV_reference.object(ii).meansqerr(test,CV_weight.object(ii)))		
	file.printf("# CV Measures RMS error \t%g\n", penalty)
	file.printf("#	FSL Mean %g, Std Dev %g \n",  fslmean,fslstd)
	
	
	
	//Calculate additional penalties
	
	//Penalty: Number of trials counted in CV 
	if(checkedtrials < 0.8*reps) penalty =10
	file.printf("# Checked trials \t%g\n", checkedtrials)
	file.printf("# Checked trials penalty\t%g\n", penalty)
	
	//Penalty 1: Sustained rate 
	sustainedrate = psth.sum(2,6)/25
	file.printf("# Sustained rate \t%g\n", sustainedrate)
	
	if (ii > 1)	{
		//penalty for lack of spikes during tone
		if(sustainedrate < 10) penalty = 10 - sustainedrate 
		file.printf("# Sustained rate penalty \t%g\n", penalty)
	}
	//penalty for too many spikes after tone
	if(psth.sum(8,12)/25 > 10) penalty = psth.sum(8,12)/25 - 10 
		file.printf("# Post stimulus rate penalty \t%g\n", penalty)
	
	
	
	//Penalty 3: CV follows criteria for chopper
	//First 10 ms must be strongly regular
	penalty=0
	if(cvISI.x[0] > 0.2) penalty+= 10
	if(cvISI.x[0] > 0.3) penalty+= 100
	if (sustained_transient_chopper==0){
		//Sustained model	
		if(cvISI.x[1] > 0.3 || cvISI.x[1] == 0) penalty+= 10
		if(cvISI.x[2] > 0.3 || cvISI.x[2] == 0) penalty+= 10
		if(cvISI.x[3] > 0.3 || cvISI.x[3] == 0) penalty+= 10
	} else {
		//Transient models
		if(cvISI.x[1] > 0.5 || cvISI.x[1] == 0) penalty+= 10
		if(cvISI.x[2] > 0.5 || cvISI.x[2] == 0) penalty+= 10
		if(cvISI.x[3] > 0.5 || cvISI.x[3] == 0) penalty+= 10 
	}
	
	file.printf("#	CV Penalty = %g\n",penalty)
	file.printf("\t\t")
}//ii  for loop

		//Penalty 4: Input resistance must be within physiological range
		access tstellate[whichcell][0].soma 
		inputresistance = rn() //Calculate input resistance, see Utilities.hoc   
		if(inputresistance < 30 || inputresistance > 400) penalty = 100
		file.printf("#  Input Resistance = %g\n",inputresistance)
		file.printf("#  Input Resistance Penalty = %g\n",penalty)
		file.printf("#  tonefreq = %g\n",tonefreq)
		param.printparams(file,"#") //let Network Parameters print the struct
	}
	file.close()
	//Write parameters to general optimisation file
	sprint(fname,"%s/pvec_%s.hoc",fileroot,origfileroot)
	file.aopen(fname)
	file.printf(" // %s  \n",datestr)
	for pp=0,NPARAMS-1 {
		file.printf("%s = %g*%g\n",pvec_name.object(pp).s,pvec.x[pp],pvec_factor.x[pp])
	}
	file.close()
	reps = cur_reps
	PSTHcell(TSspikeList.object(1),10,2)
	PSTHcell(TSspikeList.object(1),1,2)
	PSTHcell(TSspikeList.object(1),0.25,2)
}
