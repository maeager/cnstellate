/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/*
 *   DS_RateLevel.hoc
 * 
 *   
 *    Copyright Â© 2012 Michael Eager, (mick.eager@gmail.com)
 *    cnstellate was written as part of my PhD at the University of Melbourne
 *
 *    This file is part of cnstellate.
 * 
 *    This is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
 */



load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")

xopen("Params.hoc")           // default parameters
xopen("Utilities.hoc")
xopen("NetworkParameters.hoc")
xopen("AuditoryNerve.hoc")
xopen("par_CNcell.tem")      // CN cell template
xopen("parameters_DS_RateLevel.hoc")     //This model's parameters
xopen("CochlearNucleus.hoc")         // model set-up
xopen("cngui.hoc")

//--- Setup Auditory and CN Stellate model
create_cells()
connect_cells(fileroot)
connect_CNcells(fileroot)
//Previous optimisation parameters
xopen("pvec_Golgi_RateLevel.hoc")
xopen("pvec_DS_ClickRecovery.hoc")

reset_weights()
reset_DS_ClickRecovery()

xopen("jitter.hoc")
//Call:   jitterdelay_DS(param.delay.x[hsr][ds],0.2)

// Replacement of connect_cells in Cochlear Nucleus.hoc
strdef cmd
proc connect_cells_DS(){local i,p,target,source,low,high,range,channel,sourcechannel
	
    print "Connecting cells"
    sprint(filename,"%s.connect",$s1)
    outfile.wopen(filename)
	
    hsr2tsAMPAlist.remove_all()
    lsr2tsAMPAlist.remove_all()
        hsr2dsAMPAlist.remove_all()
    lsr2dsAMPAlist.remove_all()
    hsr2glgAMPAlist.remove_all()
    lsr2glgAMPAlist.remove_all()
    glg2dsGABAlist.remove_all()
    glg2tsGABAlist.remove_all()
    
	print "HSR->DS"
	if( ( param.n.getval(hsr,ds) > 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",hsr,ds)
		channel = whichcell
		target = 0
		for i=0, param.n.getval(hsr,ds)-1{
			//Choose source channel
			sourcechannel = random.normal(channel,param.bw.getval(hsr,ds)/2)
			if ((sourcechannel - int(sourcechannel)) > 0.5 ){
				sourcechannel = 1+int(sourcechannel)
			} else { 
				sourcechannel = int(sourcechannel) 
			}
			if (sourcechannel <=0 ) sourcechannel=0
			if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
			//Choose random source from available cells
			source = random.discunif(0,HSRsperchannel-1)
			//print "HSR[",sourcechannel,"][",source,"] connected to DS[",channel,"][",target,"]"
			sprint(cmd, "dstellate[%d][%d].soma hsr2dsAMPAlist.append( new NetCon( an.HSR[%d][%d],  dstellate[%d][%d].AMPA,thresh,param.delay.getval(hsr,ds), param.w.getval(hsr,ds)))",channel,target,sourcechannel,source,channel,target)
			execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
			outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
			
		}
		
		p = 100*(channel)/(nchannels)
		printf("\r=== %3d%% ===",p)
		flushf()
		doNotify() // Although this slows down cell creation, the
        // process is so long that we have to allow the
        // user to quit during the creation.
		
	}
	print "LSR->DS"
	if( ( param.n.getval(lsr,ds) > 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",lsr,ds)
		channel = whichcell
		target = 0
		for i=0, param.n.getval(lsr,ts)-1{
			//Choose source channel
			sourcechannel = random.normal(channel,param.bw.getval(lsr,ds)/2)
			if ((sourcechannel - int(sourcechannel)) > 0.5 ){
				sourcechannel = 1+int(sourcechannel)
			} else { 
				sourcechannel = int(sourcechannel) 
			}
			if (sourcechannel <=0 ) sourcechannel=0
			if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
			//Choose random source from available cells
			source = random.discunif(0,LSRsperchannel-1)
			//print "LSR[",sourcechannel,"][",source,"] connected to DS[",channel,"][",target,"]"
			sprint(cmd, "dstellate[%d][%d].soma lsr2dsAMPAlist.append( new NetCon( an.LSR[%d][%d],  dstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ds), param.w.getval(lsr,ds)))",channel,target,sourcechannel,source,channel,target)
			execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
			outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
		}
		p = 100*(channel)/(nchannels)
		printf("\r=== %3d%% ===",p)
		flushf()
		doNotify() // Although this slows down cell creation, the
		// process is so long that we have to allow the
		// user to quit during the creation.
	}
	print "GLG->DS"
	if( ( param.n.getval(glg,ds) > 0 ) && ( nDSperchannel != 0 ) && ( nGperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",glg,ds)
		channel = whichcell
		target = 0
		for i=0, param.n.getval(glg,ds)-1{
			//Choose source channel
			sourcechannel = random.normal(channel,param.bw.getval(glg,ds)/2)
			if ((sourcechannel - int(sourcechannel)) > 0.5 ){
				sourcechannel = 1+int(sourcechannel)
			} else { 
				sourcechannel = int(sourcechannel) 
			}
			if (sourcechannel <=0 ) sourcechannel=0
			if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
			//Choose random source from available cells
			source = random.discunif(0,nGperchannel-1)
			// print "GLG[",sourcechannel,"][",source,"] connected to "DS[",channel,"][",target,"]"
			if (LSR2GLG ==1 ) {
				sprint(cmd, "golgi[%d][%d].soma glg2dsGABAlist.append( new NetCon(&v(0.5),dstellate[%d][%d].GABAA,thresh,param.delay.getval(glg,ds), param.w.getval(glg,ds)))",sourcechannel, source, channel, target )
				execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
			} else {
				sprint(cmd, "glg2dsGABAlist.append( new NetCon( golgi[%d][%d].sg,dstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ds), param.w.getval(glg,ds)))",sourcechannel, source ,channel ,target )
				execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
			}
			outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
		}
	}
	outfile.close
	jitterdelay_DS(param.delay.x[hsr][ds],1)
}

//Setup this experiment
xopen("par_experiment_DS_RateLevel.hoc")


//--- Setup Auditory model
//create_cells()
objref dstellate[nchannels][1]

dstellate[ArnottFig3_CFpos][0] = new CNcell(2,cf.x[ArnottFig3_CFpos],ArnottFig3_CFpos)
dstellate[ArnottFig12_CFpos][0] = new CNcell(2,cf.x[ArnottFig12_CFpos],ArnottFig12_CFpos)

//connect_cells_DS(fileroot)
reset_DS_RateLevel()
xopen("cngui.hoc")
//reset_DS_RateLevel()

//create_connect_TV(fileroot)

//overload SaveSpikes from CochlearNucleus.hoc
proc SaveSpikes(){local ii 
	an.SaveSpikes()
	dstellate[ArnottFig3_CFpos][0].SaveSpikes() 
	dstellate[ArnottFig12_CFpos][0].SaveSpikes()
	for ii=0,nchannels-1 {
        golgi[ii][0].SaveSpikes()
	}
	
}
proc ClearSpikes(){local ii,jj
	dstellate[ArnottFig3_CFpos][0].ClearSpikes()
	dstellate[ArnottFig12_CFpos][0].ClearSpikes()
	ClearInputSpikes()

	print "Cleared CN cell Spikes"
}


proc multi_run(){local irep,xtime
    xtime = startsw()
    ClearSpikes()
    for irep=0,reps-1{
		GenInputSpikes()
		print irep
		//run()
		stdinit()
		continuerun(tstop)
        SaveSpikes()
    }
    print "Multi_run time:", startsw() - xtime
}





//////////Default Parameters for DS_RateLevel///////////////

ANsoundspath	    = "../../sounds"
cfhi				= 48000
cflo				= 200
RefreshCF()
dur                 = 0.049
ramplngth			= 0.002
stimdelay			= 0.02   //sec, 20 msec
dutycycle                       = 0.2 //, usually 0.2
reps				= 25     //
ANmodel				= 6      // Zilany Bruce model version 3
species				= 1      // Cat
ANFBgr					= new Graph()
usesavedfilterbanks		= 1
srate					= 500000
stimtdres				= 1/srate
sg_rate					= 50000
sg_tdres				= 1/sg_rate
whichcell = ArnottFig3_CFpos

proc DS_BFtone(){
	stimtype	= 1     // Pure Tone
	dur		= 0.049  // duration of stim (seconds)
	tonefreq        = cf.x[whichcell] //Hz, unit 1 CF
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

proc DS_Noise(){
	stimtype			= 6     //BBN 
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

DS_BFtone()
SetInputRates()
GenInputSpikes()

//  ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()

/*
proc DS_2tone(){
	stimtype			= 9     //TwoTone
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = 6600 //Hz, unit 1 CF
	tone2freq           = 9350 //Hz ,unit 2 
	tone2spl            = spl // set the second tone's sound level to the same as the first
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

*/

/*


//xopen("TV_Notch.ses")

objref fitgr,gg
//DS rate-level  Optimisation
objref gr,target_ratelevel, dslist, fvec,dvec,ivec,weighting,errorvec
objref anrate[nchannels],rate_level_graph
gr = new Graph()


//
// Fitness/error function
//
proc plot_fitgr(){
    objref fitgr
    fitgr = new Graph()
//    expected_notch[1].plot(fitgr,freq1_notch,4,1)
//    CNrate[tv].plot(fitgr,cf,3,1)
//    type2_1oct_sweep[1].plot(fitgr,freq_1oct,5,1)
//    fitgr.exec_menu("View = plot")
}

objref templevel,indlevel,errorvec,refvec

reps=20
strdef origfileroot
origfileroot = fileroot

error=0
strdef datestr,grlbl
objref ivec //,pval[NPARAMS]
ivec= new Vector()
ivec.append(3,9,7,5,1,2,8,6,4,0,10,11,12,13)




*/


objref ind,isi
isistdev =0
func meanrate(){ local i localobj spikes
    // Take in a spike vector ( presume an appended vector of 50 spike trains)
	// remove values less than the stimulus delay
	// calculate intervals, remove negative intervals,
	// mean rate is the inverse of the isi mean
	objref ind,isi
	spikes = new Vector()
	if ($o1.size < reps*2 ) {
		isistdev = 10
		if ($o1.size() <= 0) return 0
		return $o1.size()/(reps*(dur+ramplngth/2))
	}
	spikes.copy($o1)
	ind = new Vector()
	isi = new Vector()
	ind.indvwhere(spikes,"<",stimdelay*1000)
	if (spikes.size - ind.size <= 5) {
		isistdev = 10
		return spikes.size()/(reps*(dur+ramplngth/2))
	}
	if (ind.size > 0) for i=0, ind.size-1 { spikes.remove(ind.x[i]-i) }
	//print "print spikes.size ", spikes.size
	for i=1,spikes.size-1 {
		isi.append( spikes.x[i]-spikes.x[i-1])
	}
	//print "print isi.size ", isi.size
	
	ind.indvwhere(isi,"<=",0)
	if (isi.size -ind.size <= 10) {
		isistdev = 10
		return spikes.size()/(reps*(dur+ramplngth/2))
	}
	if (ind.size > 0) for i=0, ind.size-1 { 
		isi.remove(ind.x[i]-i)
//		print "removing ", ind.x[i] 
	}
	ind.indvwhere(isi,">", (dur+ramplngth/2)*1000)
	if (ind.size >= 1) {
		if (isi.size - ind.size <= 3) {
			isistdev = 15
			return spikes.size()/(reps*(dur+ramplngth/2))
		}
		for i=0, ind.size-1 { 
			isi.remove(ind.x[i]-i)
//			print "removing ", ind.x[i] 
		}
	}
//	print "print isi.size", isi.size
	 
	if (isi.size < 3) {
		isistdev = 1e6
		return spikes.size()/(reps*(dur+ramplngth/2))
	}
	
	isistdev = isi.stdev()
	return 1000/isi.mean()
}

level_offset=0
objref  grate[nchannels],dsrate[nchannels],hsrrate[nchannels],lsrrate[nchannels],rate_level_graph, level,fvec

proc Ratelevel(){local ispl,i,j,count,sum,runtime,cell,xtime localobj tmp	
	count = 0
	
	for i=0,99 {
		dsrate[i] = new Vector()
		lsrrate[i] = new Vector()
		hsrrate[i] = new Vector()
		grate[i] = new Vector()
	}
	fvec = new Vector()
	//RefreshParameters()
	//ANFilterBankRun()
	for ispl=0,level.size-1 {
		spl = level.x[ispl] - level_offset
		runtime = startsw()
		ClearSpikes()
		RefreshParameters()
		ANFilterBankRun()
		SetInputRates()
		multi_run()
		ANSpikes()
		meanrate(dstellate[whichcell][0].spikes)
		dsrate[whichcell].append(dstellate[whichcell][0].spikes.size / (reps * 0.05))		
		//for j=0,nchannels-1 {
		j=whichcell 
		{	
			meanrate(golgi[j][0].spikes)
			grate[j].append(golgi[j][0].spikes.size / (reps * 0.05))

			for ii=1,HSRsperchannel-1 an.HSRspikes[j][0].append(an.HSRspikes[j][ii])
			for ii=1,LSRsperchannel-1 an.LSRspikes[j][0].append(an.LSRspikes[j][ii])
			meanrate(an.HSRspikes[j][0])
			meanrate(an.LSRspikes[j][0])
			
			hsrrate[j].append(an.HSRspikes[j][0].size / (HSRsperchannel * reps * 0.05))
			lsrrate[j].append(an.LSRspikes[j][0].size / (LSRsperchannel * reps * 0.05))
		}

		
		count+=1
		runtime = startsw()-runtime
		print "Simulation took ",runtime, " secs "
	}
	
	rate_level_graph = new Graph()
//	fvec.plot(rate_level_graph,2,2)
	grate[whichcell].plot(rate_level_graph,level,5,1)	
	dsrate[whichcell].plot(rate_level_graph,level,3,1)	
	hsrrate[whichcell].plot(rate_level_graph,level,4,1)
	lsrrate[whichcell].plot(rate_level_graph,level,5,1)
	rate_level_graph.exec_menu("View = plot")
	
}//Ratelevel



/*
TV_BFtone()
level=new Vector(20)
level.indgen().mul(3).add(20) //20:3:60
Ratelevel()
TV_Noise()
level=new Vector(20)
level.indgen().mul(2).add(50)
Ratelevel()



for i = 0, nchannels-1 {
	dstellate[i][0].soma.gnabar_rm=0.408307 
	dstellate[i][0].soma.gkhtbar_rm=0.030623 
	dstellate[i][0].soma.gleak_rm=0.000274146 
	dstellate[i][0].soma.erev_rm= -65 
	dstellate[i][0].soma.ghbar_rm=0.000427944
	dstellate[i][0].soma.gkltbar_klt=0.0163897
}

param.w.x[lsr][tv] = 0.0021707
param.w.x[hsr][tv] = 0.0006168


//Initial values
param.w.x[glg][ds]	= 0.000532	
param.w.x[hsr][ds]	= 0.00127  
param.w.x[lsr][ds]	= 0.00309  
param.w.x[tv][ds]	= 0.00  
param.w.x[ds][tv]	= 0.0018  
reset_weights()



//QuickRun()
//spl=50
//sprint(fileroot,"%s_spl50",origfileroot)
//param.w.x[hsr][tv]=-0.0002
//param.w.x[lsr][tv]*=2
objref origpvec
//set_pvec()
//origpvec = pvec.c



DS_BFtone()
level=new Vector(20)
level.indgen().mul(20).add(20) //20:20:100
Ratelevel()
DS_Noise()
level=new Vector(20)
level.indgen().mul(10).add(50) //50:10:100
Ratelevel()
*/


// Target RL data
objref target_rate_level[4],fitgr, toneRL[8], noiseRL[8]
fitgr = new Graph()

error1=0
error2=0
error3=0
error4=0

proc show_fit_curves(){
	level=new Vector(5)
	level.indgen().mul(20).add(20) //20:20:100
	target_rate_level[0] = set_target_rate_level(Arnott2004_Fig3_Tone)

	level=new Vector(6)
	level.indgen().mul(10).add(50) //50:10:100
	target_rate_level[2] = set_target_rate_level_noise(Arnott2004_Fig3_Noise)
	
	 fitgr = new Graph()
	  
     target_rate_level[0].plot(fitgr)
     //target_rate_level[1].plot(fitgr,toneRL[0],2,1)
     target_rate_level[2].plot(fitgr)
     //target_rate_level[3].plot(fitgr,level,2,1)
	 fitgr.exec_menu("View = plot")
}


func DS_RateLevel_err(){local jj,pp,xtime
    xtime=startsw()
    //check for bad values
    for pp=0,NPARAMS-1 {
		if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
			return 1e9
		}
    }
	//print variables
	print "DS_RateLevel_err ", $1 
    for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp]) }
	//Set the parameters (see parameters_TV_Notch.hoc)
	for pp=0,NPARAMS-1 {
		sprint(cmd,"%s = %g * %g \n",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
		execute1(cmd)
    }
	//Rearrange synapses is using weight parameters
	//connect_cells(fileroot)  connect_CNcells(fileroot)
	connect_cells_DS(fileroot)
	//reset_weights()

	DS_BFtone()
	level=new Vector(15)
	level.indgen().mul(5).add(30) //20:10:100
	Ratelevel()
	if (whichcell == ArnottFig3_CFpos){
		target_rate_level[0] =set_target_rate_level(Arnott2004_Fig3_Tone)
	} else {
		target_rate_level[0] =set_target_rate_level(Arnott2004_Fig12_Tone)
		
	}
	error1 = sqrt(dsrate[whichcell].meansqerr(target_rate_level[0]))

	toneRL[0] =  level.c
	toneRL[1] =  dsrate[whichcell].c
	toneRL[2] =  grate[whichcell].c
	toneRL[3] =  hsrrate[whichcell].c
	toneRL[4] =  lsrrate[whichcell].c
	
	save_rate_level()	
	DS_Noise()
	level=new Vector(12)
	level.indgen().mul(5).add(40) //50:10:100
	Ratelevel()
	if (whichcell == ArnottFig3_CFpos){
		target_rate_level[2] =set_target_rate_level(Arnott2004_Fig3_Noise)
	} else {
       target_rate_level[2] =set_target_rate_level(Arnott2004_Fig12_Noise)
	}
	error3 = sqrt(dsrate[whichcell].meansqerr(target_rate_level[2]))
        noiseRL[0] =	level.c
	noiseRL[1] =  dsrate[whichcell].c
	noiseRL[2] =  grate[whichcell].c
	noiseRL[3] =  hsrrate[whichcell].c
	noiseRL[4] =  lsrrate[whichcell].c
	
	save_rate_level()	
	//Plot the results
	 if(object_id(fitgr)==0) fitgr = new Graph()
	 fitgr.erase_all()
     toneRL[1].plot(fitgr,toneRL[0],1,2)
     toneRL[2].plot(fitgr,toneRL[0],2,2)
     dsrate[whichcell].plot(fitgr,level,1,2)
     
     target_rate_level[0].plot(fitgr,toneRL[0],1,1)
     //target_rate_level[1].plot(fitgr,toneRL[0],2,1)
     target_rate_level[2].plot(fitgr,level,1,1)
     //target_rate_level[3].plot(fitgr,level,2,1)

     sprint(grlbl,"Error1 = %g", error1)
     fitgr.label(0.05,0.85,grlbl)
	 sprint(grlbl,"Error2 = %g", error2)
	 fitgr.label(0.05,0.75,grlbl)
	 sprint(grlbl,"Error3 = %g", error3)
	 fitgr.label(0.05,0.65,grlbl)
	 sprint(grlbl,"Error4 = %g", error4)
     fitgr.label(0.05,0.55,grlbl)
	 
	 for jj=0,NPARAMS-1{
		sprint(grlbl,"%s = %g", pvec_name.object(jj).s,pvec.x[jj])
		fitgr.label(0.65,0.45-0.05*jj,grlbl)
    }
	fitgr.exec_menu("View = plot")	
	doNotify()
	
	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
    }
	file.printf("%g\n",error1+error2+error3+error4)
	file.close()
	
	print "DS_RateLevel_err complete. Error ", error1+error2+error3+error4, " time (sec)", startsw() - xtime
	
    return error1+error2+error3+error4
}

func DS_RateLevel_err2(){local jj,pp,xtime
    xtime=startsw()
    //check for bad values
    for pp=0,NPARAMS-1 {
		if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
			return 1e9
		}
    }
	//print variables
	print "DS_RateLevel_err ", $1 
    for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp]) }
	//Set the parameters (see parameters_TV_Notch.hoc)
	for pp=0,NPARAMS-1 {
		sprint(cmd,"%s = %g * %g \n",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
		execute1(cmd)
    }
	//Rearrange synapses is using weight parameters
	//connect_cells(fileroot)  connect_CNcells(fileroot)
	connect_cells_DS(fileroot)
	//reset_weights()

	DS_BFtone()
	level=new Vector(15)
	level.indgen().mul(5).add(30) //20:10:100
	Ratelevel()
	if (whichcell == ArnottFig3_CFpos){
		target_rate_level[0] =set_target_rate_level(Arnott2004_Fig3_Tone)
	} else {
		target_rate_level[0] =set_target_rate_level(Arnott2004_Fig12_Tone)
		
	}
	error1 = dsrate[whichcell].c.sub(target_rate_level[0]).div(target_rate_level[0].c.add(0.1)).abs().mean()

	toneRL[0] =  level.c
	toneRL[1] =  dsrate[whichcell].c
	toneRL[2] =  grate[whichcell].c
	toneRL[3] =  hsrrate[whichcell].c
	toneRL[4] =  lsrrate[whichcell].c
	
	save_rate_level()	
	DS_Noise()
	level=new Vector(12)
	level.indgen().mul(5).add(40) //50:10:100
	Ratelevel()
	if (whichcell == ArnottFig3_CFpos){
		target_rate_level[2] =set_target_rate_level(Arnott2004_Fig3_Noise)
	} else {
       target_rate_level[2] =set_target_rate_level(Arnott2004_Fig12_Noise)
   }
   error3 = dsrate[whichcell].c.sub(target_rate_level[2]).div(target_rate_level[2].c.add(0.1)).abs().mean()
   
   noiseRL[0] =	level.c
	noiseRL[1] =  dsrate[whichcell].c
	noiseRL[2] =  grate[whichcell].c
	noiseRL[3] =  hsrrate[whichcell].c
	noiseRL[4] =  lsrrate[whichcell].c
	
	save_rate_level()	
	//Plot the results
	 if(object_id(fitgr)==0) fitgr = new Graph()
	 fitgr.erase_all()
     toneRL[1].plot(fitgr,toneRL[0],1,2)
     toneRL[2].plot(fitgr,toneRL[0],2,2)
     dsrate[whichcell].plot(fitgr,level,1,2)
     
     target_rate_level[0].plot(fitgr,toneRL[0],1,1)
     //target_rate_level[1].plot(fitgr,toneRL[0],2,1)
     target_rate_level[2].plot(fitgr,level,1,1)
     //target_rate_level[3].plot(fitgr,level,2,1)

     sprint(grlbl,"RL Error = %g", error1)
     fitgr.label(0.05,0.85,grlbl)
	// sprint(grlbl,"Error2 = %g", error2)
	// fitgr.label(0.05,0.75,grlbl)
	 sprint(grlbl,"NRL Error = %g", error3)
	 fitgr.label(0.05,0.65,grlbl)
	// sprint(grlbl,"Error4 = %g", error4)
    // fitgr.label(0.05,0.55,grlbl)
	 
	 for jj=0,NPARAMS-1{
		sprint(grlbl,"%s = %g", pvec_name.object(jj).s,pvec.x[jj])
		fitgr.label(0.65,0.45-0.05*jj,grlbl)
    }
	fitgr.exec_menu("View = plot")	
	doNotify()
	
	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
    }
	file.printf("%g\n",error1+error2+error3+error4)
	file.close()
	
	print "DS_RateLevel_err complete. Error ", error1+error2+error3+error4, " time (sec)", startsw() - xtime
	
    return error1+error2+error3+error4
}



proc QuickRun(){
    set_pvec()
    pvec.printf
    print DS_RateLevel_err(0,&pvec.x[0])
}

proc runprax2(){
    sprint(cmd,"mkdir -p %s",fileroot)
    system(cmd)
    sprint(cmd,"touch %s/error_out.dat",fileroot)
    system(cmd)
    attr_praxis(0.01, 0.01, 3)
    fit_praxis(NPARAMS,"DS_RateLevel_err2",&pvec.x[0])
}

proc runprax(){
	attr_praxis(0.001, 0.001, 3)
	fit_praxis(NPARAMS,"DS_RateLevel_err2",&pvec.x[0])
}

strdef origfileroot
origfileroot=fileroot

strdef datestr
datestr=""
strdef cmd
cmd=""
error=0
proc printprax2(){local pp,ii,pp2,error
//Output model data with best parameters
  sprint(cmd,"mkdir -p %s",fileroot)
  system(cmd)
error=DS_RateLevel_err2(0,&pvec.x[0])
print error
system("date",datestr)
print datestr
sprint(fname,"%s/%s.Fit.dat",fileroot,origfileroot)
file.wopen(fname)
if (file.isopen()){
file.printf("# %s Optimisation\n",fileroot)
file.printf("# %s \n",datestr)
for pp=0,NPARAMS-1 {
file.printf("#%s = %g\t[%g,%g]\n",pvec_name.object(pp).s,pvec.x[pp]*pvec_factor.x[pp],pvec_ranges.x[pp][0],pvec_ranges.x[pp][1])
}
file.printf("# RL Error = %g\n", error1)
file.printf("# NRL Error = %g\n", error3)
file.printf("# Final error = %g\n",error)
// file.printf("# Principle axis matrix\n")
// for pp=0,NPARAMS-1 {
// 	pval[pp] = new Vector(NPARAMS)
// 	pval_praxis(pp,&pval[pp].x[0])	
//	file.printf("#\t")
//	if (pval[pp].size == NPARAMS){
//for pp2=0,NPARAMS-1 file.printf("%g\t",pval[pp].x[pp2])
//	}
//	file.printf("\n")
// }
file.printf("# Level, DS Model, GLG, HSR, LSR (sp/s)\n")
for i=0,level.size-1{
	file.printf("%d\t%g\t%g\t%g\t%g\t%g\n",level.x[i],\
	target_rate_level[2].x[i],\
	dsrate[whichcell].x[i],grate[whichcell].x[i],\
	hsrrate[whichcell].x[i],lsrrate[whichcell].x[i])
}
file.printf("\n\n",error)
for i=0,toneRL[0].size-1{
	file.printf("%d\t%g\t%g\t%g\t%g\t%g\n",toneRL[0].x[i],\
	target_rate_level[0].x[i],\
	toneRL[1].x[i],toneRL[2].x[i],\
	toneRL[3].x[i],toneRL[4].x[i])
}		
file.printf("#Other values \n")
 file.printf("#tonefreq = %g\n",cf.x[whichcell])
// file.printf("#  halfoct_compress = %g\n",  halfoct_compress)
// file.printf("#  halfoct_shift = %g\n",  halfoct_shift)
// file.printf("# oct_compress = %g\n", oct_compress)
// file.printf("# oct_shift  = %g\n", oct_shift )
// file.printf("# centrepoint = %g\n",centrepoint)
//file.printf("# DS erev = %g\n",tuberculoventral[0][0].soma.erev_rm)
param.printparams(file,"#") //let Network Parameters print the struct
file.close()
}
//Write parameters to general optimisation file
sprint(fname,"%s/pvec_%s.hoc",fileroot,origfileroot)
file.aopen(fname)
file.printf(" // %s  \n",datestr)
for pp=0,NPARAMS-1 {
file.printf("%s = %g\n",pvec_name.object(pp).s,pvec.x[pp]*pvec_factor.x[pp])
    }
file.close()
}



proc run_multipleprax(){
set_pvec()
reps=10
runprax()
printprax2()
reps=10
runprax()
printprax2()
//reps=5
runprax2()
reps=50
printprax2()
}
//run_multipleprax()

proc Rerun_ANmodel_tone(){
	DS_BFtone()
		create_cells()
	for i=0,99 {
		dsrate[i] = new Vector()
		lsrrate[i] = new Vector()
		hsrrate[i] = new Vector()
		grate[i] = new Vector()
	}	
	for (spl=20;spl<=100;spl+=10){
    RefreshParameters()
    ANFilterBankRun()
    //SaveANFilterBank2File()
    //for i=0,nchannels-1 golgi[i][0].SetRate2()
    //SaveGolgiFilterBank2File()
    SetInputRates()	

    ClearSpikes()
    for irep=0,reps-1{
		GenInputSpikes()
        SaveSpikes()
    }	
	ANSpikes()
	for j=0,nchannels-1 {
			meanrate(golgi[j][0].spikes)
			grate[j].append(golgi[j][0].spikes.size / (reps * 0.05))
			for i=1,HSRsperchannel-1 an.HSRspikes[j][0].append(an.HSRspikes[j][i])
			for i=1,LSRsperchannel-1 an.LSRspikes[j][0].append(an.LSRspikes[j][i])
			meanrate(an.HSRspikes[j][0])
			meanrate(an.LSRspikes[j][0])
			hsrrate[j].append(an.HSRspikes[j][0].size / (HSRsperchannel * reps * 0.05))
			lsrrate[j].append(an.LSRspikes[j][0].size / (LSRsperchannel * reps * 0.05))
		}
	} 
    fitgr.erase_all()
    hsrrate[whichcell].plot(fitgr,20,1,1)
    lsrrate[whichcell].plot(fitgr,20,2,1)
    grate[whichcell].plot(fitgr,20,3,1)
}

proc Rerun_ANmodel_noise(){

	DS_Noise()
	create_cells()
	for i=0,99 {
		dsrate[i] = new Vector()
		lsrrate[i] = new Vector()
		hsrrate[i] = new Vector()
		grate[i] = new Vector()
	}	
	for (spl=40;spl<=100;spl+=10){
    RefreshParameters()
    ANFilterBankRun()
    //SaveANFilterBank2File()
    //for i=0,nchannels-1 golgi[i][0].SetRate2()
    //SaveGolgiFilterBank2File()
    SetInputRates()	
    ClearSpikes()
    for irep=0,reps-1{
		GenInputSpikes()
        SaveSpikes()
    }	
	ANSpikes()
	for j=0,nchannels-1 {
			meanrate(golgi[j][0].spikes)
			grate[j].append(golgi[j][0].spikes.size / (reps * 0.05))
			for i=1,HSRsperchannel-1 an.HSRspikes[j][0].append(an.HSRspikes[j][i])
			for i=1,LSRsperchannel-1 an.LSRspikes[j][0].append(an.LSRspikes[j][i])
			meanrate(an.HSRspikes[j][0])
			meanrate(an.LSRspikes[j][0])
			hsrrate[j].append(an.HSRspikes[j][0].size / (HSRsperchannel * reps * 0.05))
			lsrrate[j].append(an.LSRspikes[j][0].size / (LSRsperchannel * reps * 0.05))
		}
	} 
    fitgr.erase_all()
    hsrrate[whichcell].plot(fitgr,10,1,1)
    lsrrate[whichcell].plot(fitgr,10,2,1)
    grate[whichcell].plot(fitgr,10,3,1)
}


whichcell=ArnottFig12_CFpos

    dstellate[whichcell][0].soma.gnabar_rm=0.408307 
	dstellate[whichcell][0].soma.gkhtbar_rm=0.030623 
	dstellate[whichcell][0].soma.gleak_rm=0.000274146/2 
	dstellate[whichcell][0].soma.erev_rm=-70 
	
	reps=10	
	QuickRun()
	xopen("DS_RateLevel/pvec_DS_RateLevel.hoc")	
	run_multipleprax()
