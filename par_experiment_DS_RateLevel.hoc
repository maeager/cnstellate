/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/* par_experiment_DS_RateLevel.hoc
 *   
 *    Copyright Â© 2012 Michael Eager, (mick.eager@gmail.com)
 *
 *    This file is part of cnstellate.
 * 
 *    This is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
 */



objref file
file = new File()

/* 

Target data
Arnott, Palmer, Wallace et al, 2004
D stellate cell (OnC) rate-level 
Figure 3

Sound level in dB attenuation refers to noise spectrum level at 0 dB equal to \~40 dB re 20 $\mu$Pa/Hz$^{1/2}$.

Data is in spikes per stimulus for a 50 ms tone/noise burst.  This needs to be converted to firing rate (sp per ms)

*/

//////////Default Parameters for DS_RateLevel///////////////


ANsoundspath	    = "../../sounds"
cfhi				= 48000  //Hz
cflo				= 200    //Hz
dur                 = 0.049  //ms
ramplngth			= 0.002  //ms
stimdelay			= 0.02   //sec, 20 msec
dutycycle           = 0.2    //ratio, usually 0.2
reps				= 25     //
ANmodel				= 6      // Zilany Bruce model version 3
species				= 1      // Cat
ANFBgr				= new Graph()
usesavedfilterbanks	= 1
srate				= 500000    //Hz
stimtdres			= 1/srate   //s
sg_rate				= 50000     //Hz
sg_tdres			= 1/sg_rate //s

RefreshCF()
GetAudiogramData()


// wc -l  DS_RateLevel/Arnott2004_Fig*.dat
//  20 DS_RateLevel/Arnott2004_Fig3_CF6.3kHz.Noise.dat
//  20 DS_RateLevel/Arnott2004_Fig3_CF6.3kHz.Tone.dat


objref Arnott2004_Fig3_Noise, Arnott2004_Fig3_Tone
Arnott2004_Fig3_Tone = new Matrix()
Arnott2004_Fig3_Noise = new Matrix()
file.ropen("DS_RateLevel/Arnott2004_Fig3_CF6.3kHz.Tone.dat")
if (file.isopen()) Arnott2004_Fig3_Tone.scanf(file,20,2)
file.close()
file.ropen("DS_RateLevel/Arnott2004_Fig3_CF6.3kHz.Noise.dat")
if (file.isopen()) Arnott2004_Fig3_Noise.scanf(file,20,2)
file.close()
ArnottFig3_CFpos = FindInd(6300)  //Find position closest to unit's CF=6.3kHz


objref Arnott2004_Fig12_Noise, Arnott2004_Fig12_Tone
Arnott2004_Fig12_Tone = new Matrix()
Arnott2004_Fig12_Noise = new Matrix()
file.ropen("DS_RateLevel/Arnott2004_Fig12_CF10.9kHz.Tone.png.dat")
if (file.isopen()) Arnott2004_Fig12_Tone.scanf(file,17,2)
file.close()
file.ropen("DS_RateLevel/Arnott2004_Fig12_CF10.9kHz.Noise.png.dat")
if (file.isopen()) Arnott2004_Fig12_Noise.scanf(file,20,2)
file.close()
ArnottFig12_CFpos = FindInd(10900)  //Find position closest to unit's CF=10.9kHz


// Target RL data
objref tmp_rate_level, level, dsrate[nchannels],grate[nchannels], hsrrate[nchannels],lsrrate[nchannels]

/// Save rate-level values to file
proc save_rate_level(){
	sprint(fname,"%s/rate_level.dat",fileroot)
	file.aopen(fname)
	for i=0,level.size-1{
		file.printf("%d\t%g\t%g\t%g\t%g\n",level.x[i],\
		dsrate[whichcell].x[i],grate[whichcell].x[i], \
		hsrrate[whichcell].x[i],lsrrate[whichcell].x[i])
			
	}
	file.close()
}	

/// Save rate-level values to file
proc save_rate_level_network(){local ii,jj
	sprint(fname,"%s/rate_level.dat",fileroot)
	file.aopen(fname)
	for jj=0,nchannels-1 {
	for ii=0,level.size-1{
		file.printf("%d\t%g\t%g\t%g\t%g\n",level.x[ii],\
		dsrate[jj].x[ii],grate[jj].x[ii], \
		hsrrate[jj].x[ii],lsrrate[jj].x[ii])			
	}
	file.printf("\n\n")
	}
	file.close()
}	


// set_target_rate_level(target 2D matrix)
// set RL optimisation data 
// convert xdata to dB SPL and ydata to sp/s
//Note the level vector must be set prior to calling this function 
obfunc set_target_rate_level(){localobj xdata,ydata
	if (level.size == 0) {
		print "set_target_rate_level: 'level' vector not big enough"
		return tmp_rate_level
	}
	if ( object_id($o1) && $o1.nrow >= 2 && $o1.ncol >= 2){
		xdata = $o1.getcol(0).add(100)  //0 dBA in data approx. 40dB SPL
		ydata = $o1.getcol(1).div(0.05) //convert spikes per stimulus to spikes per ms for a 50 ms stimulus
		tmp_rate_level = new Vector()
		tmp_rate_level.interpolate(level,xdata,ydata)
	} else {
		print "set_target_rate_level: Error interpolating data. "
	}
	return tmp_rate_level
}

// set_target_rate_level_noise(target 2D matrix) 
// set NRL optimisation data 
// convert xdata to dB SPL and ydata to sp/s
// Note the level vector must be set prior to calling this function 
obfunc set_target_rate_level_noise(){localobj xdata,ydata
	if (level.size == 0) {
		print "Error setting data"
		return tmp_rate_level
	}
	if ( object_id($o1) && $o1.nrow >= 2 && $o1.ncol >= 2){
		xdata = $o1.getcol(0).add(100)  //0 dBA in data approx. 40dB SPL
		ydata = $o1.getcol(1).div(0.05) //convert spikes per stimulus to spikes per ms for a 50 ms stimulus
		tmp_rate_level = new Vector()
		tmp_rate_level.interpolate(level,xdata,ydata)
	} else {
		print "Error interpolating data"
	}
	return tmp_rate_level
	
}

// Redundant proc see RefreshCellParams in CochlearNucleus.hoc
strdef cmd
proc reset_DS_RateLevel(){local i  
  for i=0,nchannels -1 {
  	  if (object_id(dstellate[i][0])) {
		  sprint(cmd,"dstellate[%d][0].soma.gkhtbar_rm = param.ds_gkhtbar",i)
		  execute1(cmd)
		  sprint(cmd,"dstellate[%d][0].soma.gleak_rm = param.ds_gleak",i)
		  execute1(cmd)
		  sprint(cmd,"dstellate[%d][0].soma.gkltbar_klt =  param.ds_gkltbar",i)
		  execute1(cmd)
		  sprint(cmd,"dstellate[%d][0].soma.gkltbar_rm =  param.ds_gnabar",i)
		  execute1(cmd)
	  }
  }
}


xopen("jitter.hoc")
//Call:   jitterdelay_DS(param.delay.x[hsr][ds],0.2)


// Replacement of connect_cells in Cochlear Nucleus.hoc
strdef cmd
proc connect_cells_DS(){local i,p,target,source,low,high,range,channel,sourcechannel
	
    print "Connecting cells"
    sprint(filename,"%s.connect",$s1)
    outfile.wopen(filename)
	
    hsr2tsAMPAlist.remove_all()
    lsr2tsAMPAlist.remove_all()
        hsr2dsAMPAlist.remove_all()
    lsr2dsAMPAlist.remove_all()
    hsr2glgAMPAlist.remove_all()
    lsr2glgAMPAlist.remove_all()
    glg2dsGABAlist.remove_all()
    glg2tsGABAlist.remove_all()
    
	print "HSR->DS"
	if( ( param.n.getval(hsr,ds) > 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",hsr,ds)
		channel = whichcell
		target = 0
		for i=0, param.n.getval(hsr,ds)-1{
			//Choose source channel
			sourcechannel = random.normal(channel,param.bw.getval(hsr,ds)/2)
			if ((sourcechannel - int(sourcechannel)) > 0.5 ){
				sourcechannel = 1+int(sourcechannel)
			} else { 
				sourcechannel = int(sourcechannel) 
			}
			if (sourcechannel <=0 ) sourcechannel=0
			if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
			//Choose random source from available cells
			source = random.discunif(0,HSRsperchannel-1)
			//print "HSR[",sourcechannel,"][",source,"] connected to DS[",channel,"][",target,"]"
			sprint(cmd, "dstellate[%d][%d].soma hsr2dsAMPAlist.append( new NetCon( an.HSR[%d][%d],  dstellate[%d][%d].AMPA,thresh,param.delay.getval(hsr,ds), param.w.getval(hsr,ds)))",channel,target,sourcechannel,source,channel,target)
			execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
			outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
			
		}
		
		p = 100*(channel)/(nchannels)
		printf("\r=== %3d%% ===",p)
		flushf()
		doNotify() // Although this slows down cell creation, the
        // process is so long that we have to allow the
        // user to quit during the creation.
		
	}
	print "LSR->DS"
	if( ( param.n.getval(lsr,ds) > 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",lsr,ds)
		channel = whichcell
		target = 0
		for i=0, param.n.getval(lsr,ts)-1{
			//Choose source channel
			sourcechannel = random.normal(channel,param.bw.getval(lsr,ds)/2)
			if ((sourcechannel - int(sourcechannel)) > 0.5 ){
				sourcechannel = 1+int(sourcechannel)
			} else { 
				sourcechannel = int(sourcechannel) 
			}
			if (sourcechannel <=0 ) sourcechannel=0
			if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
			//Choose random source from available cells
			source = random.discunif(0,LSRsperchannel-1)
			//print "LSR[",sourcechannel,"][",source,"] connected to DS[",channel,"][",target,"]"
			sprint(cmd, "dstellate[%d][%d].soma lsr2dsAMPAlist.append( new NetCon( an.LSR[%d][%d],  dstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ds), param.w.getval(lsr,ds)))",channel,target,sourcechannel,source,channel,target)
			execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
			outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
		}
		p = 100*(channel)/(nchannels)
		printf("\r=== %3d%% ===",p)
		flushf()
		doNotify() // Although this slows down cell creation, the
		// process is so long that we have to allow the
		// user to quit during the creation.
	}
	print "GLG->DS"
	if( ( param.n.getval(glg,ds) > 0 ) && ( nDSperchannel != 0 ) && ( nGperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",glg,ds)
		channel = whichcell
		target = 0
		for i=0, param.n.getval(glg,ds)-1{
			//Choose source channel
			sourcechannel = random.normal(channel,param.bw.getval(glg,ds)/2)
			if ((sourcechannel - int(sourcechannel)) > 0.5 ){
				sourcechannel = 1+int(sourcechannel)
			} else { 
				sourcechannel = int(sourcechannel) 
			}
			if (sourcechannel <=0 ) sourcechannel=0
			if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
			//Choose random source from available cells
			source = random.discunif(0,nGperchannel-1)
			// print "GLG[",sourcechannel,"][",source,"] connected to "DS[",channel,"][",target,"]"
			if (LSR2GLG ==1 ) {
				sprint(cmd, "golgi[%d][%d].soma glg2dsGABAlist.append( new NetCon(&v(0.5),dstellate[%d][%d].GABAA,thresh,param.delay.getval(glg,ds), param.w.getval(glg,ds)))",sourcechannel, source, channel, target )
				execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
			} else {
				sprint(cmd, "glg2dsGABAlist.append( new NetCon( golgi[%d][%d].sg,dstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ds), param.w.getval(glg,ds)))",sourcechannel, source ,channel ,target )
				execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
			}
			outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
		}
	}
	outfile.close
	jitterdelay_DS(param.delay.x[hsr][ds],1)
}




proc DS_BFtone(){
	stimtype	= 1      // Pure Tone
	dur		    = 0.049  //s, duration of stim
	tonefreq    = cf.x[whichcell] //Hz, unit 1 CF
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

proc DS_Noise(){
	stimtype	= 6     // BBN stimulus type 
	dur			= 0.049 //s, duration of stim
	tstop		= 70    //ms
	spl			= 20    //dB SPL
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}


proc DS_2tone(){
	stimtype			= 9    // TwoTone
	dur				    = 0.049//sec, duration of stim
	tstop				= 70   //ms
	spl				    = 20   //dB SPL
	tonefreq            = 6600 //Hz, unit 1 CF
	tone2freq           = 9350 //Hz, unit 2 
	tone2spl            = spl  //dB SPL, set the second tone's sound level to the same as the first
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}
