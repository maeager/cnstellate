/*
 *	par_MTF.hoc
 *
 */
load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")
thresh=-20

		xopen("mathslib.hoc")			// mathematical procedures
		xopen("Params.hoc")
		xopen("Utilities.hoc")
		xopen("NetworkParameters.hoc")
		xopen("AuditoryNerve.hoc")
		xopen("par_CNcell.tem")		// CN cell template
		xopen("parameters_ClickDelay.hoc")           // model parameters	
//		if (pnm.myid == 0)  print "Creating network"
//		xopen("par_CochlearNucleus.hoc")			// model set-up
//		if (pnm.myid == 0)  print "Reading input procedures"
//		xopen("par_input.hoc")		// define procedures to set-up input
//		if (pnm.myid == 0)  print "Setting-up experiment"
//		xopen("par_experiment_SAM.hoc")
//		xopen(filename)             

objref an,golgi[nchannels][1],g
an = new AuditoryNerve()
for i=0,99 {
   for j = 0, HSRsperchannel-1 {
      //sprint(celltype,"new SGC_fast(%d,%d,%d)",4,cf.x[i],i)
      an.HSR[i][j] = new SGC_fast(0.5)
    }
    for j = 0, LSRsperchannel-1 {
      //sprint(celltype,"new ANF(%d,%d,%d)",5,cf.x[i],i)
      an.LSR[i][j] = new SGC_fast(0.5)
    }
     golgi[i][0] = new Golgicell(3,cf.x[i],i,2)
}
    
    


objref  ANFBgr,  Sout[nchannels]

objref stimgr,b1,gr

objref  ANFBgr, b2, Sout[nchannels]
changescale=1
scale = 60
proc ShowInputGraphs() {
	objref stimgr, b1, gr
	objref  ANFBgr, b2, Sout[nchannels]


	b1 = new VBox()
	b1.intercept(1)
	stimgr = new Graph(0)
	stimgr.view(0, -0.01, 0.042, 0.02, 308, 88, 685, 150)
	stimgr.label(0.1, 0.91, grlbl)
	stimgr.label(0.0, 0.65, "Amplitude  (uPascals)")
	stimgr.label(0.85, 0.35, "time (ms)")	
	stim.plot(stimgr, stimtdres)
	stimgr.exec_menu("View = plot")
	//b1.intercept(0)
	//b1.map("Stimulus waveform",360, 0, 650.7, 193.5)


	//b1.intercept(1)
	ANFBgr = new Graph(0)
	ANFBgr.size(0,0.05,0,180000)
	ANFBgr.view(0, 0, 0.05, 180000, 308, 345, 685, 365)
	ANFBgr.label(0.92,0.90, "CF")
	ANFBgr.label(0.1,0.95,"Auditory Filterbank Instantaneous Rate Profiles")
	for icf = 0, nchannels-1 { 
		Sout[icf] = HSRout[icf].c 
		Sout[icf].mul(2).add(6000*icf)
		Sout[icf].plot(ANFBgr,sg_tdres, 1, 0)
		sprint(lbl, "%g ", cf.x[icf])
		ANFBgr.label(0.92, 0.810*(icf/(nchannels-1))+0.075, lbl)
	}
	//system("date")
	ANFBgr.exec_menu("View = plot")
	b1.intercept(0)
	b1.map("Stimulus and Auditory Filterbank",308, 345, 685, 365)
	

}//Input Graphs

proc ShowGolgiGraphs() {
	
	objref  ANFBgr,  Sout[nchannels]

	ANFBgr = new Graph(0)
	ANFBgr.size(0,0.05,0,180000)
	ANFBgr.view(0, 0, 0.05, 180000, 308, 345, 685, 365)
	ANFBgr.label(0.92,0.90, "CF")
	ANFBgr.label(0.1,0.95,"Auditory Filterbank Instantaneous Rate Profiles")
	for icf = 0, nchannels-1 { 
		Sout[icf] = golgi[icf][0].sout.c 
	Sout[icf].add(icf) 
		Sout[icf].plot(ANFBgr,sg_tdres, 1, 0)
		sprint(lbl, "%g ", cf.x[icf])
		ANFBgr.label(0.92, 0.810*(icf/(nchannels-1))+0.075, lbl)
	}
	//system("date")
	ANFBgr.exec_menu("View = plot")
	

	print "To save graph type: ANFBgr.printfile(\"x.eps\")"
}//





//Setup Auditory model

	cfhi=64000
	cflo=200

	dur 		= 0.08 	//duration of stim (seconds)
	srate 		= 500000.0  
	stimtdres 	= 1/srate
	sg_rate 	= 50000		
	sg_tdres 	= 1/sg_rate
	stimdelay 	= 0.01		//sec
	stimtype	= 2		//Silence
	ANmodel		= 6		//Zilany Bruce model
	species		= 2		//Rat
	nrep		= 1  		//nrep is number of reps of stimulus



ANFBgr = new Graph()
usesavedfilterbanks=1
/*
ANFilterBankRun()	//Build the filterbank
an.SetRates()		//Allocate filterbanks to ANFs
ShowInputGraphs()
*/

//ShowGolgiGraphs()

//D-stellate Click train PSTH   (Backoff et al. 1997
objref gr,targetclick, dslist,clicktimes,stim
proc ClickRecovery(){
//Input stimuli
	objref clicktimes
	clicktimes = new Vector()
	clicktimes.append(20,22,40,44,60,68).mul(srate/1000)
//Target response
	//Fraction of repetitions that ellicit a response
	targetclick = new Vector()
	targetclick.append(1,0.2,1,0.45,1,0.6)

	srate = 500000
	stimtdres = 1/srate
	stim = new Vector(int(dur/stimtdres),0)
	for i=0,clicktimes.size-1{
	  for j=0,20 stim.x[clicktimes.x[i]+j] = spl2ampl(180)
	}
	reps=25
	binsize=0.1
	stim.plot(ANFBgr,stimtdres)
	ANFBgr.exec_menu("View = plot")
	ANFBgr.printfile("Clickstim.eps")
	objref ANFBgr
	
	ANFilterBankRun()
	an.SetRates()
	ShowInputGraphs()
	ANFBgr.printfile("ClickFB.eps")
}//ClickRecovery


objref ind,isi
isistdev =0
func meanrate(){ local i localobj spikes
// Take in a spike vector ( presume an appended vector of 50 spike trains)
// remove values less than the stimulus delay
// calculate intervals, remove negative intervals,
// mean rate is the inverse of the isi mean
	objref ind,isi
	spikes = new Vector()
	if ($o1.size < 60) {
		isistdev = 10
		return $o1.size()/(reps*0.05)
	}
	spikes.copy($o1)
	ind = new Vector()
	isi = new Vector()
	ind.indvwhere(spikes,"<",20)
	if (spikes.size -ind.size <= 50) {
		isistdev = 10
		return spikes.size()/(reps*0.05)
	}
	if (ind.size > 0) for i=0, ind.size-1 { spikes.remove(ind.x[i]-i) }
print "print spikes.size", spikes.size
	for i=1,spikes.size-1 { 
		isi.append( spikes.x[i]-spikes.x[i-1]) 
	}
print "print isi.size", isi.size

	ind.indvwhere(isi,"<=",0)
	if (isi.size -ind.size <= 10) {
		isistdev = 10
		return spikes.size()/(reps*0.05)
	}
	if (ind.size > 0) for i=0, ind.size-1 { isi.remove(ind.x[i]-i) 
print "removing ", ind.x[i] }
	ind.indvwhere(isi,">",50)
	if (ind.size >= 1) {
	 if (isi.size -ind.size <= 3) {
		isistdev = 15
		return spikes.size()/(reps*0.05)
	 }
	 for i=0, ind.size-1 { isi.remove(ind.x[i]-i) 
print "removing ", ind.x[i] }
	}
print "print isi.size", isi.size

	if (isi.size <= 1) {
		isistdev = 1e6
		return spikes.size()/(reps*0.05)
	} 

	isistdev = isi.stdev() 	
	return 1000/isi.mean()
}


objref gpstlist, grate[nchannels],anrate[nchannels],rate_level_graph, gstdev[nchannels]
proc RatelevelGolgi1(){local i,j,count,sum,runtime,cell,xtime localobj tmp
	//objref Notchgr,results[sp.cells.count], Notch

	count = 0
	tonefreq = cf.x[76]
	dur 		= 0.049 	//duration of tone segment (seconds)
		
	dutycycle 	= 0.2		//quiet duration = dutycycle*dur
	ramplngth 	= 0.001
	srate 		= 500000.0  stimtdres 	= 1/srate
	sg_rate = 50000		sg_tdres = 1/sg_rate
	stimdelay = 0.02		//sec
	stimtype=1	//tone
	reps=50
	gpstlist = new List()
	for i=0,99 {
		grate[i] = new Vector()
		anrate[i] = new Vector()
		gstdev[i] = new Vector()
	}
	//RefreshParameters()
	//ANFilterBankRun()
	for (spl = -20; spl <= 95; spl+=5){
		runtime = startsw()
		ClearSpikes()
		RefreshParameters()
		
		ANFilterBankRun()
		SetRates()
		
		for j=0, reps-1{ 
			GenInputSpikes()
			print j
			SaveSpikes()
			//print startsw()-x, "secs" 
		}
		
		for j=0,99 {
		sum=0
			grate[j].append(meanrate(golgi[j][0].spikes))
			gstdev[j].append(1000/isistdev)
			for i=0,LSRsperchannel-1 sum+= meanrate(an.LSRspiketimes[j][i])
			anrate[j].append(sum/(LSRsperchannel))
		}
		

		count+=1
		runtime = startsw()-runtime
		print "Simulation took ",runtime, " secs "
	}

	rate_level_graph = new Graph()
	grate[76].plot(rate_level_graph)
	anrate[76].plot(rate_level_graph)
	rate_level_graph.exec_menu("View = plot")


	file.wopen("GolgiRateLevel.dat")
	file.printf("# Golgi model rate-level data\n")
	file.printf("# Spatial filter: Stdev of LSR input channels=%.2f\n",golgi_spatial_filter_stdev)
	file.printf("# Synaptic Filter: Tau = 5ms, Scale_factor=%.2f\n",golgi_syn_filter_scale_factor)
	file.printf("# SPL\tRate (sp/sec)\t Stdev\n")
	for i=0,23 file.printf("%d\t%.3f\t%.3f\n",i*5-20,grate[76].x[i],gstdev[76].x[i])
	file.close()
}



	count = 0
	dur 		= 0.049 	//duration of tone segment (seconds)
		
	dutycycle 	= 0.2		//quiet duration = dutycycle*dur
	ramplngth 	= 0.001
	srate 		= 500000.0  
	stimtdres 	= 1/srate
	sg_rate = 50000		
	sg_tdres = 1/sg_rate
	stimdelay 	= 0.02		//sec
	stimtype=1	//tone
	reps=25
		

objref gr, targetrl, rlst,level,isi,ind
level = new Vector(22)
level.indgen().mul(5).add(-15)
targetrl = new Vector()
targetrl.append(2.53,	2.14,	4.28,	6.24,	7.80,	12.10,	10.73,	13.47,	17.96,27.92,30.27,	32.81,	39.84,	51.75,	57.42,	58.00,	58.79,	62.11,	68.75,	82.62,	92.38,	100.78)
gr = new Graph()
rlst = new List()
targetrl.plot(gr,level,2,2)
gr.size(-20,100,0,150)
gr.exec_menu("Keep Lines")


objref g, dvec, fvec,ivec
g = new Graph()
g.size(0,3,0,3)
count = 0
func fun() {local f,mspikerate
       if ($1 == 90) {
                g.line($2*$3, $3*$4)
                g.flush()
		doNotify()
//		print "spl ", $1,"a (scaling) ", $2,"b (stdev) ", $3
		}	

	if ($1 == -15 && count != 0){
		fvec.plot(Graph[0],ivec,1,1)
		Graph[0].flush()
		doNotify()
	}
	spl=$1
	//weight_sum=$2
	golgi_spon=$2
	golgi_spatial_filter_stdev =$3	
	golgi_syn_filter_scale_factor=$4
	runtime = startsw()
	golgi[76][0].ClearSpikes()
	tonefreq = cf.x[76]
	RefreshParameters()
	sg_rate=50000
	ANFilterBankRun() 
	sg_rate = 50000 
	sg_tdres = 1/sg_rate
	CreateGolgiSynFilter()
	golgi[76][0].SetRate()
		
	for j=0, reps-1{ 
		golgi[76][0].GenSpikes()
		print j
		golgi[76][0].SaveSpikes()
		//print startsw()-x, "secs" 
	}

	runtime = startsw()-runtime
	print "Simulation took ",runtime, " secs "
	mspikerate = meanrate(golgi[76][0].spikes)
	print "Mean: ",mspikerate , " stdev: ", isistdev
	return mspikerate //golgi[76][0].spikes.size()/(reps*0.05)

}


objref vv


dvec = new Vector()
ivec = new Vector()
reps = 50

vv = new Vector()
vv.append(0,6,10,14,18,21) //2,6,14,18,20
dvec = targetrl.ind(vv)
ivec = level.ind(vv)
fvec = new Vector(4)
//fvec.fill(0)

a = 1.5
b = 4
c = 1

proc RunFit(){
g.beginline()
error = dvec.fit(fvec, "fun", ivec, &a, &b, &c)
print a, b, c, error
g.flush()
g.exec_menu("View = plot")
fvec.plot(Graph[1],ivec,1,1)
}
//RunFit()
//RunFit()
//RatelevelGolgi1()


objref gpstlist, grate[nchannels],anrate[nchannels],rate_level_graph, gstdev[nchannels]
proc MTFfunction(){local i,j,count,sum,runtime,cell,xtime localobj tmp
	//objref Notchgr,results[sp.cells.count], rMTF, tMTF, freq
	count = 0
	dur 		= 0.049 	//duration of tone segment (seconds)
		
	dutycycle 	= 0.2		//quiet duration = dutycycle*dur
	ramplngth 	= 0.001
	srate 		= 500000.0  stimtdres 	= 1/srate
	sg_rate = 50000		sg_tdres = 1/sg_rate
	stimdelay = 0.02		//sec
	stimtype=6	//tone
	reps=50
	gpstlist = new List()
	for i=0,99 {
		grate[i] = new Vector()
		anrate[i] = new Vector()
		gstdev[i] = new Vector()
	}
	//RefreshParameters()
	//ANFilterBankRun()
	for (spl = 0; spl <= 95; spl+=5){
		runtime = startsw()
		ClearSpikes()
		RefreshParameters()
		
		ANFilterBankRun()
		SetRates()
		
		for j=0, reps-1{ 
			GenInputSpikes()
			print j
			SaveSpikes()
			//print startsw()-x, "secs" 
		}
		
		for j=0,99 {
		sum=0
			grate[j].append(meanrate(golgi[j][0].spikes))
			gstdev[j].append(1000/isistdev)
			 
			for i=0,LSRsperchannel-1 sum+= meanrate(an.LSRspiketimes[j][i])
			anrate[j].append(sum/(LSRsperchannel))
		}
		print "Golgi 50: LSR 50 "
		grate[50].printf
		anrate[50].printf
		

		count+=1
		runtime = startsw()-runtime
		print "Simulation took ",runtime, " secs "
	}

	rate_level_graph = new Graph()
	grate[76].plot(rate_level_graph)
	anrate[76].plot(rate_level_graph)
	rate_level_graph.exec_menu("View = plot")


	file.wopen("GolgiRateLevelNoise.dat")
	file.printf("# Golgi model rate-level-noise data\n")
	file.printf("# Spatial filter: Stdev of LSR input channels=%.2f\n",golgi_spatial_filter_stdev)
	file.printf("# Synaptic Filter: Tau = 5ms, Scale_factor=%.2f\n",golgi_syn_filter_scale_factor)
	file.printf("# SPL\tRate (sp/sec)\t Stdev\n")
	for i=0,23 file.printf("%d\t%.3f\t%.3f\n",i*5-20,grate[76].x[i],gstdev[76].x[i])
	file.close()
}

RatelevelNoiseGolgi1()
