// cn.hoc
// Cochlear Nucleus network model: network specification file
// Michael Eager
// University of Melbourne
//
objref cvode, random
cvode = new CVode(0)    // start with CVode inactive
random = new Random(seed)
random.MCellRan4(seed+1)

if (nTSperchannel > 0) { objref tstellate[nchannels][nTSperchannel]
}else objref tstellate[1][1]
if (nTVperchannel > 0) {objref tuberculoventral[nchannels][nTVperchannel]
} else objref tuberculoventral[1][1]
if (nDSperchannel > 0){ objref dstellate[nchannels][nDSperchannel]
} else  objref dstellate[1][1]
if (nGperchannel > 0) { objref golgi[nchannels][nGperchannel]
} else objref golgi[1][1]



objref hsr2tsAMPAlist, lsr2tsAMPAlist,hsr2tvAMPAlist, lsr2tvAMPAlist, \
hsr2dsAMPAlist, lsr2dsAMPAlist, hsr2glgAMPAlist, lsr2glgAMPAlist, \
glg2dsGABAlist, glg2tsGABAlist, ds2tsGLYlist, ds2tvGLYlist, \
tv2tsGLYlist, ts2tsAMPAlist,ts2dsAMPAlist, tv2dsGLYlist,ts2tvAMPAlist

hsr2tsAMPAlist = new List()
lsr2tsAMPAlist = new List()
hsr2tvAMPAlist = new List()
lsr2tvAMPAlist = new List()
hsr2dsAMPAlist = new List()
lsr2dsAMPAlist = new List()
hsr2glgAMPAlist = new List()
lsr2glgAMPAlist = new List()
glg2dsGABAlist = new List()
glg2tsGABAlist = new List()
ds2tsGLYlist = new List()
ds2tvGLYlist = new List()
tv2dsGLYlist = new List()
tv2tsGLYlist = new List()
ts2tvAMPAlist = new List()
ts2tsAMPAlist = new List()
ts2dsAMPAlist = new List()

if (nTSperchannel > 0) objref input[nchannels][nTSperchannel]
objref outfile
outfile = new File()
strdef filename, celltype

//objref param
//param = new NetworkParameters(6,4)
//param.getnetparameters("defaultrecurrentparams.dat")
//
objref an
an = new AuditoryNerve()

//xopen("cngui.hoc")
// Create cells --------------------------------------------------------
strdef cmd
//Having trouble with local variables when using execute1

proc create_cells() { local p,i_chan,j_cell

    if (!object_id(an)) an = new AuditoryNerve()
    i_chan=0
    j_cell=0
  quitmodel = 0
 print "Creating cells. This may take some time."
  for i_chan = 0, nchannels-1 {
    if (nTSperchannel > 0) for j_cell = 0, nTSperchannel-1 {
        sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d)",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)
    }
    if (nTVperchannel > 0) for j_cell = 0, nTVperchannel-1 {
        sprint(cmd, "tuberculoventral[%d][%d] = new CNcell(1,cf.x[%d],%d)",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)
    }
    if (nDSperchannel > 0) for j_cell = 0, nDSperchannel-1 {
        sprint(cmd, "dstellate[%d][%d] = new CNcell(2,cf.x[%d],%d)",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)
    }
    if (nGperchannel > 0) for j_cell = 0, nGperchannel-1 {
      if ( LSR2GLG == 0 ) {//Golgi filterbank model
         sprint(cmd, "golgi[%d][%d] = new Golgicell(3,cf.x[%d],%d,param.bw.x[lsr][glg])",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)

      } else {  //Golgi Conductance based model
        sprint(cmd, "golgi[%d][%d] = new CNcell(3,cf.x[%d],%d)",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)
      }
    }
    for j_cell = 0, HSRsperchannel-1 {
      //sprint(celltype,"new SGC_fast(%d,%d,%d)",4,cf.x[i],i)
      an.HSR[i_chan][j_cell] = new SGC_fast(0.5)
    }
    for j_cell = 0, LSRsperchannel-1 {
      //sprint(celltype,"new ANF(%d,%d,%d)",5,cf.x[i],i)
      an.LSR[i_chan][j_cell] = new SGC_fast(0.5)
    }

    p = 100*(i_chan)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
  }
 printf("\n")
}

// Connect cells, set synaptic parameters ------------------------------

func wrap() {
  if ($1 < 0) {
    return $2+$1
  } else {
    if ($1 < $2) {
      return $1
    } else {
      return $1-$2
    }
  }
}


// When refering to "channel" in the following code
// I mean Auditory frequency-channel

proc connect_cells() {local i,p,target,source,low,high,range,channel,sourcechannel


    print "Connecting cells"
    sprint(filename,"%s.connect",$s1)
    outfile.wopen(filename)

hsr2tsAMPAlist.remove_all()
lsr2tsAMPAlist.remove_all()
hsr2tvAMPAlist.remove_all()
lsr2tvAMPAlist.remove_all()
hsr2dsAMPAlist.remove_all()
lsr2dsAMPAlist.remove_all()
hsr2glgAMPAlist.remove_all()
lsr2glgAMPAlist.remove_all()
glg2dsGABAlist.remove_all()
glg2tsGABAlist.remove_all()
ds2tsGLYlist.remove_all()
ds2tvGLYlist.remove_all()
tv2tsGLYlist.remove_all()
tv2dsGLYlist.remove_all()
ts2tsAMPAlist.remove_all()
ts2tvAMPAlist.remove_all()
ts2dsAMPAlist.remove_all()

print "HSR->TS"
if( ( param.n.getval(hsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
outfile.printf("\n%d %d\n",hsr,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(hsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(hsr,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells in sourcechannel
    source = random.discunif(0,HSRsperchannel-1)
 //print "HSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
 sprint(cmd, "tstellate[%d][%d].soma hsr2tsAMPAlist.append( new NetCon( an.HSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(hsr,ts), param.w.getval(hsr,ts)))",channel,target,sourcechannel,source,channel,target)

        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
 outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
 printf("\n")
}
print "LSR->TS"
if( ( param.n.getval(lsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",lsr,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(lsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(lsr,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,LSRsperchannel-1)
 //print "LSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
 sprint(cmd, "tstellate[%d][%d].soma lsr2tsAMPAlist.append( new NetCon( an.LSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ts), param.w.getval(lsr,ts)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
  outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
 printf("\n")
}
print "HSR->TV"
if( ( param.n.getval(hsr,tv) > 0 ) && ( nTVperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",hsr,tv)
 for channel = 0, nchannels-1{
  for target = 0, nTVperchannel-1 {
   for i=0, param.n.getval(hsr,tv)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(hsr,tv)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,HSRsperchannel-1)
   //print "HSR[",sourcechannel,"][",source,"] connected to TV[",channel,"][",target,"]"
  sprint(cmd, " tuberculoventral[%d][%d].soma hsr2tvAMPAlist.append( new NetCon( an.HSR[%d][%d],tuberculoventral[%d][%d].AMPA,thresh,param.delay.getval(hsr,tv), param.w.getval(hsr,tv)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
    outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.

 }
 printf("\n")
}
 print "LSR->TV"
if( ( param.n.getval(lsr,tv) > 0 ) && ( nTVperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",lsr,tv)
 for channel = 0, nchannels-1{
  for target = 0, nTVperchannel-1 {
   for i=0, param.n.getval(lsr,tv)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(lsr,tv)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,LSRsperchannel-1)

 //print "LSR[",sourcechannel,"][",source,"] connected to TV[",channel,"][",target,"]"

sprint(cmd, "tuberculoventral[%d][%d].soma lsr2tvAMPAlist.append( new NetCon( an.LSR[%d][%d],   tuberculoventral[%d][%d].AMPA,thresh,param.delay.getval(lsr,tv), param.w.getval(lsr,tv)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
    outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
      p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.

 }
 printf("\n")
}
 print "HSR->DS"
if( ( param.n.getval(hsr,ds) > 0 ) && ( nDSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",hsr,ds)
 for channel = 0, nchannels-1{
  for target = 0, nDSperchannel-1 {
   for i=0, param.n.getval(hsr,ds)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(hsr,ds)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,HSRsperchannel-1)
 //print "HSR[",sourcechannel,"][",source,"] connected to DS[",channel,"][",target,"]"
 sprint(cmd, "dstellate[%d][%d].soma hsr2dsAMPAlist.append( new NetCon( an.HSR[%d][%d],  dstellate[%d][%d].AMPA,thresh,param.delay.getval(hsr,ds), param.w.getval(hsr,ds)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
   outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
      p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.

 }
 printf("\n")
}
 print "LSR->DS"
if( ( param.n.getval(lsr,ds) > 0 ) && ( nDSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",lsr,ds)
 for channel = 0, nchannels-1{
  for target = 0, nDSperchannel-1 {
   for i=0, param.n.getval(lsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(lsr,ds)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,LSRsperchannel-1)
 //print "LSR[",sourcechannel,"][",source,"] connected to DS[",channel,"][",target,"]"
 sprint(cmd, "dstellate[%d][%d].soma lsr2dsAMPAlist.append( new NetCon( an.LSR[%d][%d],  dstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ds), param.w.getval(lsr,ds)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
    outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
      p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.

 }
 printf("\n")
}
if (LSR2GLG == 1){  //Only for Conductance based golgi cell
 print "LSR->GLG"
if( ( param.n.getval(lsr,glg) > 0 ) && ( nGperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",lsr,glg)
 for channel = 0, nchannels-1{
  for target = 0, nGperchannel-1 {
   for i=0, param.n.getval(lsr,glg)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(lsr,glg)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,LSRsperchannel-1)
 //print "LSR[",sourcechannel,"][",source,"] connected to Golgi[",channel,"][",target,"]"
 sprint(cmd, "golgi[%d][%d].soma lsr2glgAMPAlist.append( new NetCon( an.LSR[%d][%d],  golgi[%d][%d].AMPA, thresh,param.delay.getval(lsr,glg), param.w.getval(lsr,glg)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
    outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
      p = 100*(channel)/(nchannels)
    printf("\r=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.

 }
 printf("\n")
}
}//LSR2GLG
outfile.close()
}//connect_cells

proc connect_CNcells(){local i,target,source,low,high,range,channel,sourcechannel
  sprint(filename,"%s.connect",$s1)
  outfile.aopen(filename)

 print "Connecting CN network cells"
 print "TS->TS"
if( ( param.n.getval(ts,ts) > 0 ) && ( nTSperchannel > 1 ) ){
 outfile.printf("%d %d\n",ts,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(ts,ts)-1{
    //Choose random source from available cells
    source = random.discunif(0,nTSperchannel-1)
    while( source == target)  source = random.repick()  //Don't connect to self
 // print "TS[",channel,"][",source,"] connected to "TS[",channel,"][",target,"]"
 // tscells[channel*numTSperchannel+target].connect_pre(tscells[source], 1, param.delay.getval(ts,ts), param.w.getval(ts,ts))
 sprint(cmd, "tstellate[%d][%d].soma ts2tsAMPAlist.append( new NetCon(&v(0.5), tstellate[%d][%d].AMPA, thresh,param.delay.getval(ts,ts), param.w.getval(ts,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
    outfile.printf("%d %d %d %d\n",channel,source,channel,target)

   }
  }
 }
  printf("\n")
}
 print "TV->TS"
if( ( param.n.getval(tv,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nTVperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",tv,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(tv,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(tv,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nTVperchannel-1)
 // print "TV[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
				sprint(cmd, "tuberculoventral[%d][%d].soma tv2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR,  thresh,param.delay.getval(tv,ts), param.w.getval(tv,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
 }
  printf("\n")
}
 print "DS->TS"
if( ( param.n.getval(ds,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nDSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",ds,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(ds,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(ds,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nDSperchannel-1)
 // print "DS[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
				sprint(cmd, "dstellate[%d][%d].soma ds2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR, thresh,param.delay.getval(ds,ts), param.w.getval(ds,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
  outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
  }
  }
 }
  printf("\n")
}
 print "DS->TV"
if( ( param.n.getval(ds,tv) > 0 ) && ( nTVperchannel != 0 ) && ( nDSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",ds,tv)
 for channel = 0, nchannels-1{
  for target = 0, nTVperchannel-1 {
   for i=0, param.n.getval(ds,tv)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(ds,tv)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nDSperchannel-1)
 // print "DS[",sourcechannel,"][",source,"] connected to "TV[",channel,"][",target,"]"
		sprint(cmd, "dstellate[%d][%d].soma ds2tvGLYlist.append( new NetCon(&v(0.5), tuberculoventral[%d][%d].GlyR, thresh,param.delay.getval(ds,tv), param.w.getval(ds,tv)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
    outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
   }
  }
 }
  printf("\n")
}
 print "GLG->DS"
if( ( param.n.getval(glg,ds) > 0 ) && ( nDSperchannel != 0 ) && ( nGperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",glg,ds)
 for channel = 0, nchannels-1{
  for target = 0, nDSperchannel-1 {
   for i=0, param.n.getval(glg,ds)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(glg,ds)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nGperchannel-1)
 //print "Golgi[",sourcechannel,"][",source,"] connected to DStellate[",channel,"][",target,"]"
   if (LSR2GLG ==1 ) {
	   sprint(cmd, "golgi[%d][%d].soma glg2dsGABAlist.append( new NetCon(&v(0.5),dstellate[%d][%d].GABAA,thresh,param.delay.getval(glg,ds), param.w.getval(glg,ds)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   } else {
	   sprint(cmd, "glg2dsGABAlist.append( new NetCon(golgi[%d][%d].s, dstellate[%d][%d].GABAA, thresh, param.delay.getval(glg,ds), param.w.getval(glg,ds)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
   }
 outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
   }
  }
 }
  printf("\n")
}

 print "GLG->TS"
if( ( param.n.getval(glg,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nGperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",glg,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(glg,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(glg,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
   if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1

    //Choose random source from available cells
    source = random.discunif(0,nGperchannel-1)
 // print "GLG[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
   if (LSR2GLG ==1 ) { //Conductance model of golgi
	   sprint(cmd, "golgi[%d][%d].soma glg2tsGABAlist.append( new NetCon(&v(0.5),tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   } else { //filter based model of golgi
		   sprint(cmd, "glg2tsGABAlist.append( new NetCon( golgi[%d][%d].s, tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
   }
     outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
  }
  }
 }
  printf("\n")
}
  outfile.close()
}//end connect_cells()




// Add input currents --------------------------------------------------

proc insert_iclamps() { local i,j, ran // 2 args - del dur
  // if $1 is negative, delay is randomly chosen in the uniform interval 0,$1
  for i = 0, nchannels-1 {
    for j = 0, nTSperchannel-1 {

      sprint(cmd, "tstellate[i][j].soma input[i][j] = new IClamp(0.5)")
        execute1(cmd)
      sprint(cmd, "input[i][j].dur = %f",$2)
        execute1(cmd)
      sprint(cmd, "input[i][j].del = abs(%f)",$1)
        execute1(cmd)

    }
  }
  random.uniform(0,abs($1))
  if ($1 < 0) {
    for i = 0, nchannels-1 {
      for j = 0, nTSperchannel-1 {
         ran = random.repick()

         sprint(cmd, "input[i][j].del = ran")
         execute1(cmd)

      }
    }
  }
}

// Randomise initial conditions ----------------------------------------

proc random_init() { local i,j, ran
  random.normal(-65,-40)
  for i = 0,nchannels-1 {
    for j = 0, nTSperchannel-1 {
      ran = random.repick()

      sprint(cmd, "tstellate[i][j].soma.v(0.5) = ran")
         execute1(cmd)
    }
    for j = 0, nDSperchannel-1 {
      ran = random.repick()

      sprint(cmd, "dstellate[i][j].soma.v(0.5) = ran")
         execute1(cmd)

    }
    for j = 0, nTVperchannel-1 {
      ran = random.repick()

      sprint(cmd, "tuberculoventral[i][j].soma.v(0.5) = ran")
         execute1(cmd)

    }
   if (LSR2GLG == 1) { for j = 0, nGperchannel-1 {
      ran = random.repick()
     sprint(cmd, "golgi[i][j].soma.v(0.5) = ran")
         execute1(cmd)
     }}
  }
}

proc SaveSpikes(){local i,j
      
	for i=0,nchannels-1{
         for j=0,nTSperchannel-1{
            sprint(cmd, "tstellate[%d][%d].spikes.append(tstellate[%d][%d].spiketimes)",i,j,i,j)
         execute1(cmd)
         }
         for j=0,nTVperchannel-1{

            sprint(cmd, "tuberculoventral[i][j].spikes.append(tuberculoventral[i][j].spiketimes)")
            sprint(cmd, "tuberculoventral[%d][%d].spikes.append(tuberculoventral[%d][%d].spiketimes)",i,j,i,j)
		     execute1(cmd)
         }
         for j=0,nDSperchannel-1{
            sprint(cmd, "dstellate[%d][%d].spikes.append(dstellate[%d][%d].spiketimes)",i,j,i,j)
         execute1(cmd)
         }
         for j=0,nGperchannel-1{
            sprint(cmd, "golgi[%d][%d].spikes.append(golgi[%d][%d].spiketimes)",i,j,i,j)
         execute1(cmd)
         }
         for j=0,HSRsperchannel-1{
			 an.HSRspikes[i][j].append(an.HSRspiketimes[i][j])
         }
         for j=0,LSRsperchannel-1{
			 an.LSRspikes[i][j].append(an.LSRspiketimes[i][j])
         }
      }
}

proc ClearSpikes(){local i,j
    an.ClearSpikes()  
	for i=0,nchannels-1{
         for j=0,nTSperchannel-1{
 sprint(cmd, "tstellate[%d][%d].spikes.remove_all()",i,j)
         execute1(cmd)
         }
         for j=0,nTVperchannel-1{
 sprint(cmd, "tuberculoventral[%d][%d].spikes.remove_all()",i,j)
         execute1(cmd)
         }
         for j=0,nDSperchannel-1{

 sprint(cmd, "dstellate[%d][%d].spikes.remove_all()",i,j)
         execute1(cmd)

         }
         for j=0,nGperchannel-1{

 sprint(cmd, "golgi[%d][%d].spikes.remove_all()",i,j)
         execute1(cmd)

         }
      }
}

//  Create the model
// create_cells()
// connect_cells(fileroot)
// connect_CNcells(fileroot)

proc reset_weights() { local i // 1 arg - weight
//ANF connections
   for i = 0,hsr2tsAMPAlist.count()-1 {
   hsr2tsAMPAlist.object(i).weight = param.w.x[hsr][ts]
  }
   for i = 0,lsr2tsAMPAlist.count()-1 {
   lsr2tsAMPAlist.object(i).weight = param.w.x[lsr][ts]
  }
   for i = 0,hsr2tvAMPAlist.count()-1 {
   hsr2tvAMPAlist.object(i).weight = param.w.x[hsr][tv]
  }
   for i = 0,lsr2tvAMPAlist.count()-1 {
   lsr2tvAMPAlist.object(i).weight = param.w.x[lsr][tv]
  }
  for i = 0,hsr2dsAMPAlist.count()-1 {
   hsr2dsAMPAlist.object(i).weight = param.w.x[hsr][ds]
  }
   for i = 0,lsr2dsAMPAlist.count()-1 {
   lsr2dsAMPAlist.object(i).weight = param.w.x[lsr][ds]
  }
//hsr2glgAMPAlist = new List()
//lsr2glgAMPAlist = new List()

//Golgi connections
   for i = 0,glg2dsGABAlist.count()-1 {
   glg2dsGABAlist.object(i).weight = param.w.x[glg][ds]
  }
   for i = 0,glg2dsGABAlist.count()-1 {
   glg2dsGABAlist.object(i).weight = param.w.x[glg][ds]
  }
//Dstellate connections
   for i = 0,ds2tsGLYlist.count()-1 {
   ds2tsGLYlist.object(i).weight = param.w.x[ds][ts]
  }
   for i = 0,ds2tvGLYlist.count()-1 {
   ds2tvGLYlist.object(i).weight = param.w.x[ds][tv]
  }
//TV connections
   for i = 0,tv2tsGLYlist.count()-1 {
   tv2tsGLYlist.object(i).weight = param.w.x[tv][ts]
  }
   for i = 0,tv2dsGLYlist.count()-1 {
   tv2dsGLYlist.object(i).weight = param.w.x[tv][ds]
  }

//TS connections
   for i = 0,ts2tsAMPAlist.count()-1 {
   ts2tsAMPAlist.object(i).weight = param.w.x[ts][ts]
  }
   for i = 0,ts2dsAMPAlist.count()-1 {
   ts2dsAMPAlist.object(i).weight = param.w.x[ts][ds]
  }
   for i = 0,ts2tvAMPAlist.count()-1 {
   ts2tvAMPAlist.object(i).weight = param.w.x[ts][tv]
  }


}

