/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/*
 *   TStellate2.hoc
 *   Optimise parameters controlling TS cells. Second routine with three tones.
 * 
 *    cnstellate was written as part of my PhD at the University of Melbourne 
 *    Copyright Â© 2012 Michael Eager, (mick.eager@gmail.com)
 *
 *    This file is part of cnstellate.
 * 
 *    This is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
 */


load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")

xopen("mathslib.hoc")         // mathematical procedures
xopen("Params.hoc")
xopen("Utilities.hoc")
xopen("NetworkParameters.hoc")
xopen("AuditoryNerve.hoc")
xopen("par_CNcell.tem")      // CN cell template

//Previous optimisation parameters
xopen("pvec_Golgi_RateLevel.hoc")
xopen("pvec_DS_ClickRecovery.hoc")
xopen("pvec_DS_RateLevel.hoc")
xopen("pvec_TV_RateLevel.hoc")
xopen("pvec_TV_Notch.hoc")

//Parameters for this optimisation
xopen("parameters_TStellate.hoc")

//--- Setup CN Stellate Network model
xopen("CochlearNucleus.hoc")         // model set-up
// xopen("par_CochlearNucleus.hoc")   // parallel model set-up
 xopen("calcisilag.hoc")

 
// use_ball_stick=1
 
// reset_DS_ClickRecovery()
// param.w.x[hsr][ds]*	=10
// param.w.x[ds][tv]/	=10
// reset_weights()
// usesavedfilterbanks	=1


//Initial values
param.w.x[hsr][ts]		= 0.001
param.w.x[lsr][ts]		= 0.001
param.w.x[ds][ts]		= 0.0001
param.w.x[tv][ts]		= 0.0002
param.w.x[glg][ts]		= 0.0005

 param.delay.x[hsr][ts]  = 0
 param.delay.x[lsr][ts]  = 0
 param.delay.x[hsr][ds]  = 0
 param.delay.x[lsr][ds]  = 0
 param.delay.x[hsr][tv]  = 0.5
 param.delay.x[lsr][tv]  = 0.5
 param.delay.x[lsr][glg] = 1

param.n.x[hsr][ts]		= 10
param.n.x[lsr][ts]		= 10
param.n.x[ds][ts]		= 5
param.n.x[tv][ts]		= 5
param.n.x[glg][ts]		= 5
param.ts_jitter_sd = 0.5 //ms
create_cells()
objref nil
// Comment out next line to kill all TS cells not covered by experimental data
// subtypes' CFs. It reduces processing time by a fraction - enough when
// simulating multiple times
//for i=0,99 if(i != 20 || i !=38 || i != 51) tstellate[i][0] = nil


connect_cells(fileroot)
connect_CNcells(fileroot)
xopen("cngui.hoc")

xopen("psth.hoc")
xopen("par_experiment_TStellate2.hoc")


 RefreshCF()
 RefreshCNcellsCF()
 RefreshCellParams()
 
 CS_data()
 SetupChopperCV()
 SetupChopperMP()
 
 RefreshParameters()
 ANFilterBankRun()
 SetInputRates()

 
/* 
strdef datestr,grlbl
objref errorvec,tempcf,indcf,refvec,gr,ref,test,weightvec
gr = new Graph()

ref_shift=0
test_shift=0
plot_variables=0

func TStellate_err2( ) {local jj,pp,xtime,error,penalty,sustainedrate,inputresistance

    //check for bad values
    for pp=0,NPARAMS-1 {
    if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
      return 1e9
    }
    }
  //print variables
  print "TStellate_err2 ", $1
    for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])}
  //Set the parameters (see parameters_TStellate.hoc)
  for pp=0,NPARAMS-1 {
    sprint(cmd,"%s = %g * %g ",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
    execute1(cmd)
  }
flushf()
  // if (plot_variables == 1) {
  //   tgr[0].line($&2[0], $&2[1])
  //   tgr[0].flush()
  //   tgr[1].line($&2[1], $&2[2])
  //   tgr[1].flush()
  //   doNotify()
  //   print $1, $&2[0], $&2[2], $&2[3]
  // }
  
  connect_TS(fileroot)
  RefreshCellParams() //refresh_TStellate()
  jitterdelay(param.delay.x[hsr][ts],param.ts_jitter_sd)
  RunTStellate()
    //Analyse spikes
    doNotify()
    //CNSpikes2()

  // Calculate fitness
  objref errorvec,weightvec,ref,test
  errorvec = new Vector()
  weightvec = new Vector(7,1)
  ref = new Vector(7,0)
  test = new Vector(7,0)
  
  errorvec.interpolate(tvec,ivdata[0],ivdata[1])
  
  //Calculate the IV shift in depolarisation 
  ref_shift = (errorvec.max_ind(200,300)/10) - 2.5
  test_shift = (meaniv.max_ind(500,600)/10) - 2.5
  IVMeasures(tvec,errorvec,ref,ref_shift)
  IVMeasures(tvec,meaniv,test,test_shift)
  PSTHcell(tstellate_spikes,10,1)
  test.copy(cvISI, 3, 0, 3, 1, 1)
  ref.copy(CV_data, 3, 0, 3, 1, 1)
  
  //Calculate additional penalties
  penalty =0
  sustainedrate = psth.sum(2,6)/25
  if(sustainedrate < 10) penalty += 12 - sustainedrate //penalty for lack of spikes during tone
  if(checkedtrials < 0.9*reps) penalty += 5
  if(cvISI.x[0] > 0.2) penalty += 5
   if(cvISI.x[0] > 0.3) penalty += 5
  if(cvISI.x[1] > 0.5 || cvISI.x[1] == 0) penalty += 10
  if(cvISI.x[2] > 0.55 || cvISI.x[2] == 0) penalty += 10
  if(cvISI.x[3] > 0.55 || cvISI.x[3] == 0) penalty += 10  
  access tstellate[whichcell][0].soma 
  inputresistance = rn() //Calculate input resistance, see Utilities.hoc   
  if(inputresistance < 30 || inputresistance > 400) penalty += 10
  
  // Weighting of IV and CV measures
  //weightvec.x[0]/=10 //initial depolarisation approx -50 to -30  mV
  weightvec.x[1]*=10 //adaptation approx 0.2-0.5
  //weightvec.x[2]/=10 //post-tone hyperpolarisation approx 0 to -5 mV
  weightvec.x[3]*=200 //CV
  weightvec.x[4]*=200
  weightvec.x[5]*=200
  weightvec.x[6]*=200
  
  print error=sqrt(ref.meansqerr(test,weightvec)) + penalty
  
  	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
    }
	file.printf("%g\n",error)
	file.close()

  
    //plot the result
    // gr.erase_all()
    // errorvec.plot(gr,ivdata[0],1,1)
    // ivdata[1].plot(gr,ivdata[0],2,2)
    // sprint(grlbl,"Error = %g", a)
    // gr.label(0.65,0.85,grlbl)
    // for jj=0,NPARAMS-1{
  //   sprint(grlbl,"%s = %g", pvec_name.object(jj).s,pvec.x[jj])
  //   gr.label(0.65,0.75-0.05*jj,grlbl)
    // }
  doNotify()
    return error
}
*/

//tstop=300
proc QuickRun(){
  set_pvec()
  pvec.printf
  print TStellate2_err(0,&pvec.x[0])
  
}

tolerance = 0.0001
maxstepsize = 0.001
printmode = 3
strdef error_fn
error_fn = "TStellate2_err"

proc runprax(){
	//Set the attributes of the praxis method
	// tolerance : find f(x) that minimises norm(x-x0)<tolerance
	// maxstepsize: max distance between initial guess and minimum
	// printmode: verbosity of debugging output
	attr_praxis(tolerance, maxstepsize, printmode)
   fit_praxis(NPARAMS,error_fn,&pvec.x[0])
}



objref pval[NPARAMS]

objref nil
access tstellate[whichcell][0].soma
xopen("reset_weights.hoc")
xopen("voltage.ses")
xopen("jitter.hoc")


// param.w.x[lsr][ts]	= 0.000774459
// param.w.x[hsr][ts]	= 0.000817015
// param.w.x[ds][ts]	= 0.0000138011
// param.w.x[tv][ts]	= 0.0000146063
// param.w.x[glg][ts]	= 9.3936e-05
// param.ts_gleak	= 0.000494097
// param.ts_erev	=-65
// set_pvec()


// CT1_data()
// RefreshParameters()
// ANFilterBankRun()  //Generate new AN instant. rates
// SetInputRates()

// param.ts_erev	=-58
// param.w.x[ds][tv]/	=10
// param.w.x[hsr][tv]	=0.0006
// runprax()
// printprax()
// print "CT1 Done"




// //jitterdelay(0,0.5)

// //param.w.x[lsr][ts] = 0.000901216
// //param.w.x[hsr][ts] = 0.000914421
// //param.w.x[ds][ts]	= 0.00146354
// //param.w.x[tv][ts]	= 0.00132918
// //param.w.x[glg][ts] = 3.94981e-05
// //param.ts_gleak = 0.00297771


// //param.w.x[lsr][ts] = 0.000774459
// //param.w.x[hsr][ts] = 0.000817015
// //param.w.x[ds][ts]	= 0.0000138011
// //param.w.x[tv][ts]	= 0.0000146063
// //param.w.x[glg][ts] = 9.3936e-05
// //param.ts_gleak = 0.000294097
// //param.ts_erev	=-65
// //reps				=50

param.n.x[hsr][ts]=8
param.n.x[lsr][ts]=15
param.n.x[ds][ts]=4
param.n.x[tv][ts]=7
param.n.x[glg][ts]=5

param.w.x[lsr][ts]	= 0.0038
param.w.x[hsr][ts]	= 0.0009
param.w.x[ds][ts]	= 0.0000138011
param.w.x[tv][ts]	= 0.0000146063
param.w.x[glg][ts]	= 5.3936e-05
// param.ts_gleak	= 0.000494097
param.ts_erev	=-60.9
set_pvec()


proc optimise_CS(){
	CS_data()	
param.n.x[hsr][ts]=8
param.n.x[lsr][ts]=15
param.n.x[ds][ts]=4
param.n.x[tv][ts]=7
param.n.x[glg][ts]=5
param.ts_erev=-60.9
set_pvec()
RefreshParameters()
ANFilterBankRun()  //Generate new AN instant. rates
SetInputRates()
xopen("TStellate_CS/pvec_TStellate.hoc")
QuickRun()
runprax()
printprax()
//runprax()
//printprax()
//runprax()
//printprax()
//runprax()
//printprax()
print "CS Done"
PSTHcell(tstellate_spikes,10,2)
PSTHcell(tstellate_spikes,0.25,2)
}


proc optimise_CT1(){
	CT1_data()	
xopen("TStellate2_CT1/pvec_TStellate.hoc")	
	param.ts_erev=-62.9
param.n.x[hsr][ts]=12
param.n.x[lsr][ts]=15
param.n.x[ds][ts]=5
param.n.x[tv][ts]=10
param.n.x[glg][ts]=5
set_pvec()	

RefreshParameters()
ANFilterBankRun()  //Generate new AN instant. rates
SetInputRates()

//QuickRun()
runprax()
printprax()
//runprax()
//printprax()
//runprax()
//printprax()
//runprax()
//printprax()
print "CT1 Done"
PSTHcell(tstellate_spikes,10,2)
PSTHcell(tstellate_spikes,0.25,2)
}

proc optimise_CT2(){ 
	xopen("TStellate2_CT2/pvec_TStellate.hoc")
	CT2_data()
	param.ts_erev=-62.9
	param.n.x[hsr][ts]=12
	param.n.x[lsr][ts]=15
	param.n.x[ds][ts]=5
	param.n.x[tv][ts]=10
	param.n.x[glg][ts]=5	
	set_pvec()
	RefreshParameters()
	ANFilterBankRun()  
	SetInputRates()
	
	//QuickRun()
	//runprax()
	//printprax()
	//runprax()
	//printprax()
	//runprax()
	//printprax()
	runprax()
	printprax()
	print "CT2 Done"
	PSTHcell(tstellate_spikes,10,2)
	PSTHcell(tstellate_spikes,0.25,2)
}

TSexemplar_SPL_thresh=10
