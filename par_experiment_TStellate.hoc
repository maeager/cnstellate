/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/* 
 *   
 *    Copyright © 2012 Michael Eager, (mick.eager@gmail.com)
 *
 *    This file is part of cnstellate.
 * 
 *    This is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
 */


// CS and CT data were from Long-Evans and Hooded Wistar rats at RVEEH
// reported in \citep{PaoliniClareyEtAl:2005}

// -- Paolini, Clarey et al 2005 --
//     The following variables were measured from the average
//  intracellular profile (25 stimulus repetitions) at 30 dB (± 5 dB) above
//  the SPL that evoked voltage depolarization from the resting membrane
//   potential (RMP): (i) a measure of the level of initial depolarization was
//  given by the ratio of the depolarization occurring 5–10 ms after tone
//  onset to the average amplitude drop to sustained levels occurring 20–
//   30 ms after tone onset; (ii) a measure of the adaptation of sustained
//  depolarization during tone presentation was given by the difference in
//  depolarization amplitude at 20 ms and 50 ms after stimulus onset; (iii)
//  a measure of post-tone hyperpolarization was given by the change in
//  voltage, relative to RMP, 60 ms after stimulus onset (i.e. 10 ms after
//  tone offset). Membrane potential levels from traces calculated at
//  specific time points for variables 2 and 3 (i.e. 20, 50 and 60 ms) were
//  found by averaging the membrane potential over a 1-ms period (i.e.
//  20–21, 50–51 and 60–61 ms). Included in this sample are four
//  neurons whose responses to tones have been described previously
//  (Paolini & Clark, 1999; cell #: 98-280-003, 95-232-003, 98-257-002,
//  96-249-012). The intracellular response profile of all neurons reported
//  in this study was distinct from that of bushy cells (Paolini et al., 1997;
//  Paolini & Clark, 1999).


//   The cell’s rate-level function was then determined by presenting 50-ms CF
//  tone bursts (5 ms rise–fall time; 25–50 repetitions; 10 Hz repetition
//  frequency) in 5- or 10-dB steps from subthreshold sound pressure
//  levels (SPLs) to SPLs that produced discharge rate saturation. If
//  possible, frequency response areas were then determined by present-
//  ing tones at non-CF frequencies over a range of SPLs.
//     Acoustic stimuli were synthesized digitally and generated by a
//  Beyer DT48 transducer (Beyerdynamic, Farmingdale, NY, USA),
//  which was positioned at the end of a hollow ear bar and controlled
//  using a Tucker-Davis signal generator (Tucker-Davis Technologies,

stimdelay					= 0.05
dur						= 0.049
ramplngth				= 0.002
dutycycle				= 1        // get an extra 25msec post-tone
cfhi					= 40000
cflo					= 200
srate					= 100000      // 500k is no longer needed
stimtdres				= 1/srate
sg_rate					= 20000
sg_tdres				= 1/sg_rate
tstop					= 110
ANmodel					= 6
species					= 2 //Rat
audiogram_file			= "rat_bruce_audiogram.dat"
reps					= 25
usesavedfilterbanks		= 1


RefreshCF()
GetAudiogramData()

objref tempmat, ivdata[2], chopperIVgr,chopperCVgr
objref CV_sustained, CV_transient1, CV_transient2, CV_data
proc ChopperCVData(){local nrow,ncol
nrow					= 5
ncol					= 3
objref CV_sustained, CV_transient1, CV_transient2
CV_transient2			= new Matrix()
CV_transient1			= new Matrix()
CV_sustained			= new Matrix()

file					= new File()
file.ropen("TStellate/PaoliniBalancedInh-Fig2.png.dat")
if(file.isopen()){
CV_transient2.scanf(file,nrow, ncol)
CV_transient1.scanf(file,nrow, ncol)
CV_sustained.scanf(file,nrow, ncol)
file.close()
} else {
print "Error reading CV data"
}
}

//ChopperCVData()


proc CalcIVMeasures(){

    onset_depol = $o1.mean(ivdata[0].indwhere(">=",5.0), ivdata[0].indwhere(">=",10.0))
    middle_depol = $o1.mean( ivdata[0].indwhere(">=",20), ivdata[0].indwhere(">=",30))

    onset_ratio = onset_depol / middle_depol

    v20_depol = $o1.mean( ivdata[0].indwhere(">=",20) - 1, ivdata[0].indwhere(">=",21))
    v50_depol = $o1.mean( ivdata[0].indwhere(">=",50) -1, ivdata[0].indwhere(">=",51))
    adaptation_ratio = v20_depol - v50_depol

    resting_value  = $o1.mean(0 , ivdata[0].indwhere(">",0))
    v60_depol = $o1.mean(ivdata[0].indwhere(">=",60) - 1, ivdata[0].indwhere(">=",61))
    offset_hyperpol = resting_value - v60_depol

    print "resting membrane potential              ", resting_value
    print "level of initial depolarization         ", onset_depol
    print "adaptation of sustained depolarization  ", adaptation_ratio
    print "post-tone hyperpolarization             ", offset_hyperpol

}


proc CS_data() {local points
   //chopper sustained
   // unit 01-864-004
   //CV (10ms segs) always below 0.2 for 45, 65, and 75 dB
   // rate saturation at 75 dB
   // depolarisation threshold 10dB
   spl      = 40   //30 dB above depolarisation threshold
   tonefreq = 3900 //Hz, characteristic frequency
   whichcell = FindInd(tonefreq)  //get CF index close to 3.9kHz
   print "CS data CF ", tonefreq, "(Hz), location ", whichcell

   objref tempmat, ivdata[2]
   ivdata[0] = new Vector()
   ivdata[1] = new Vector()

   file.ropen("TStellate/CS-01-864-004.png.dat")

   tempmat = new Matrix()
   tempmat.scanf(file)
   ivdata[0] = tempmat.getcol(0) //time
   ivdata[1] = tempmat.getcol(1) //voltage (mV)
   file.close()
   chopperIVgr =  new Graph()
   ivdata[1].plot(chopperIVgr,ivdata[0])
   chopperIVgr.exec_menu("View = plot")
   sprint(fileroot,"TStellate_CS")    // root for output filenames
  CalcIVMeasures(ivdata[1])
  ChopperCVData()
  CV_data = CV_sustained.getcol(1).c
}

proc CT1_data() {local points

   // chopper transient 1
   // unit 01-857-007 \citep{PaoliniClareyEtAl:2005}
   // CV first 10ms <0.2, then moves above 0.2
   // this unit's depolarisation threshold  55 dB
   // average CT threshold for depolarization
   // and AP generation of 47.2 ± 2.5 and 57.4 ± 2.2 dB SPL

   spl      = 85   //30 dB above depolarisation threshold
   tonefreq = 8200 //Hz, characteristic frequency
   whichcell = FindInd(tonefreq)  //get CF index close to 8.2kHz
   print "CT1 data CF ", tonefreq, "(Hz), location ", whichcell
   file.ropen("TStellate/CT1-01-857-007.png.dat")
   objref tempmat, ivdata[2]
   ivdata[0] = new Vector()
   ivdata[1] = new Vector()
   tempmat = new Matrix() //points, 2)
   tempmat.scanf(file)
   ivdata[0] = tempmat.getcol(0) //time
   ivdata[1] = tempmat.getcol(1) //voltage (mV)
   file.close()
   chopperIVgr =  new Graph()
   ivdata[1].plot(chopperIVgr,ivdata[0])
   chopperIVgr.exec_menu("View = plot")
  sprint(fileroot,"TStellate_CT1")    // root for output filenames
  CalcIVMeasures(ivdata[1])
  ChopperCVData()
  CV_data = CV_transient1.getcol(1).c

}

proc CT2_data() {local points

   //chopper transient type 2
   // unit 01-305-014 \citep{PaoliniClareyEtAl:2005}
   //CV (10ms segs) first 10m below 0.2, then rises above 0.3
   // rate saturation at 5 dB
   spl      = 35   //30 dB above depolarisation threshold
   tonefreq = 12400 //Hz
   whichcell = FindInd(tonefreq)  //get CF index close to 12.4kHz
   file.ropen("TStellate/CT2-01-305-014.png.dat")
   print "CT2 data CF ", tonefreq, "(Hz), location ", whichcell

   objref tempmat, ivdata[2]
   ivdata[0] = new Vector()
   ivdata[1] = new Vector()
   tempmat = new Matrix() //points, 2)
   tempmat.scanf(file)
   ivdata[0] = tempmat.getcol(0) //time
   ivdata[1] = tempmat.getcol(1) //voltage (mV)
   file.close()
   chopperIVgr =  new Graph()
   ivdata[1].plot(chopperIVgr,ivdata[0])
   chopperIVgr.exec_menu("View = plot")
   sprint(fileroot,"TStellate_CT2")    // root for output filenames
  CalcIVMeasures(ivdata[1])
  ChopperCVData()
  CV_data = CV_transient2.getcol(1).c

}









CT1_data()


//RefreshParameters()    //Generate or get stim from file
//ANFilterBankRun()

binwidth=0.5
objref iv,meaniv,psthgr,tstellate_spikes
psthgr = new Graph()

proc RunTStellate(){
    objref iv,meaniv,tvec
//    ClearSpikes()
    iv = new Vector()
    iv.record(&tstellate[whichcell][0].soma.v(0.5))
    meaniv = new Vector(tstop/dt + 1,0)
    //tstellate[whichcell][0].spikes.resize(0)
	tstellate_spikes = new List()
    for ireps = 0, reps-1 {
        GenSpikes2()
        print ireps
        run()
        //SaveSpikes()
        tstellate_spikes.append(tstellate[whichcell][0].spiketimes.c)
        for i=0,tstop/dt-1{
         if (iv.x[i] > thresh) iv.x[i] = thresh
        }
        meaniv.add(iv)
        iv.mul(0)
    }
    meaniv.div(reps)
    tvec=new Vector(tstop/dt + 1)
    tvec.indgen(dt).add(-20)
    meaniv.plot(chopperIVgr,tvec)

    chopperIVgr.exec_menu("View = plot")
  CalcIVMeasures(ivdata[1])
  CalcIVMeasures(meaniv)
  //psth = tstellate[whichcell][0].spikes.histogram(0,110,binwidth)
  //psth.plot(psthgr,binwidth) psthgr.exec_menu("View = plot")
  PSTHcell(tstellate_spikes,10,1)
}

param.ts_gnabar						= 0.23677
param.ts_gkhtbar					= 0.0189416
param.ts_gleak						= 0.000473539
param.ts_erev						= -55
param.ts_ghbar						= 6.20392e-05
param.ts_gkabar						= 0.01539

proc refresh_TStellate(){local ii,jj
    print "updating features for T stellate optimisation routines"
    for ii = 0,nchannels-1 {
		for jj=0,nTSperchannel-1{
			//        if(ii == 20 || ii == 38 || ii == 51){
			sprint(cmd,"tstellate[%d][%d].soma.gnabar_rm  = param.ts_gnabar",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.gkhtbar_rm = param.ts_gkhtbar",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.gleak_rm   = param.ts_gleak",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.erev_rm    = param.ts_erev",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.ghbar_rm   = param.ts_ghbar",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.gkabar_ka  = param.ts_gkabar",ii,jj) execute1(cmd)
			
			flushf()
		}
	}
}


proc IVMeasures(){local offset
    /// args: 1 time vec, 2 voltage vec, 3 output vec (size=6), 4 offset
	if (numarg() != 4) {
		offset = 0
	} else {
		offset = $4
	}
    onset_depol = $o2.mean($o1.indwhere(">=",5.0+offset), $o1.indwhere(">=",10.0+offset))
    middle_depol = $o2.mean( $o1.indwhere(">=",20+offset), $o1.indwhere(">=",30+offset))
    onset_ratio = onset_depol / middle_depol

    v20_depol = $o2.mean( $o1.indwhere(">=",20+offset) - 1, $o1.indwhere(">=",22+offset))
    v50_depol = $o2.mean( $o1.indwhere(">=",50+offset) - 1, $o1.indwhere(">=",52+offset))
    adaptation_ratio = v20_depol - v50_depol

    resting_value  = $o2.mean($o1.indwhere(">",-10) , $o1.indwhere(">",0))
    v60_depol  = $o2.mean($o1.indwhere(">=",60+offset) - 1, $o1.indwhere(">=",65+offset))
    offset_hyperpol = resting_value - v60_depol

    $o3.x[0] = onset_ratio
    $o3.x[1] = adaptation_ratio
    $o3.x[2] = offset_hyperpol
	print "resting membrane potential              ", resting_value
	print "level of initial depolarization         ", onset_ratio
	print "adaptation of sustained depolarization  ", adaptation_ratio
	print "post-tone hyperpolarization             ", offset_hyperpol
	
}



//mimick connect_CNcells from CochlearNucleus.hoc
proc connect_TS() {local i,p,target,source,low,high,range,channel,sourcechannel
	
	objref tstellate[nchannels][nTSperchannel]
	
  for i_chan = 0, nchannels-1 {
    if (nTSperchannel > 0) for j_cell = 0, nTSperchannel-1 {
        sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d,1)",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)
    }
}	
flushf()

	
	
	
	print "Connecting cells."
	sprint(filename,"%s.connect",$s1)
	outfile.wopen(filename)
	
	
	objref 	hsr2tsAMPAlist,	lsr2tsAMPAlist,	glg2tsGABAlist,	ds2tsGLYlist,	tv2tsGLYlist,	ts2tsAMPAlist
	
	hsr2tsAMPAlist = new List()
	lsr2tsAMPAlist = new List()
	glg2tsGABAlist = new List()
	ds2tsGLYlist  = new List() 
	tv2tsGLYlist  = new List() 
	ts2tsAMPAlist  = new List()
	
	

if( ( param.n.getval(hsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
outfile.printf("\n%d %d\n",hsr,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(hsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(hsr,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells in sourcechannel
    source = random.discunif(0,HSRsperchannel-1)
	//print "HSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
	sprint(cmd, "tstellate[%d][%d].soma hsr2tsAMPAlist.append( new NetCon( an.HSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(hsr,ts), param.w.getval(hsr,ts)))",channel,target,sourcechannel,source,channel,target)
	execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
	outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\rHSR->TS === %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
 printf("\rHSR->TS === done ===\n")
}

if( ( param.n.getval(lsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",lsr,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(lsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(lsr,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,LSRsperchannel-1)
 //print "LSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
 sprint(cmd, "tstellate[%d][%d].soma lsr2tsAMPAlist.append( new NetCon( an.LSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ts), param.w.getval(lsr,ts)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
  outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\rLSR->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
 printf("\rLSR->TS=== done ===\n")
} 
flushf()	
	
	
	print "Connecting CN network cells to TS cells"
	
	
if( ( param.n.getval(ts,ts) > 0 ) && ( nTSperchannel > 1 ) ){
 outfile.printf("%d %d\n",ts,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(ts,ts)-1{
    //Choose random source from available cells
    source = random.discunif(0,nTSperchannel-1)
    while( source == target)  source = random.repick()  //Don't connect to self
 // print "TS[",channel,"][",source,"] connected to "TS[",channel,"][",target,"]"
 // tscells[channel*numTSperchannel+target].connect_pre(tscells[source], 1, param.delay.getval(ts,ts), param.w.getval(ts,ts))
 sprint(cmd, "tstellate[%d][%d].soma ts2tsAMPAlist.append( new NetCon(&v(0.5), tstellate[%d][%d].AMPA, thresh,param.delay.getval(ts,ts), param.w.getval(ts,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
    outfile.printf("%d %d %d %d\n",channel,source,channel,target)

   }
  }
        p = 100*(channel)/(nchannels)
    printf("\rTS->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rTS->TS=== done ===\n")
}
flushf()	


if( ( param.n.getval(tv,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nTVperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",tv,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(tv,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(tv,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nTVperchannel-1)
 // print "TV[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
				sprint(cmd, "tuberculoventral[%d][%d].soma tv2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR,  thresh,param.delay.getval(tv,ts), param.w.getval(tv,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
        p = 100*(channel)/(nchannels)
    printf("\rTV->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rTV->TS=== done ===\n")
}
flushf()	

if( ( param.n.getval(ds,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nDSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",ds,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(ds,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(ds,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nDSperchannel-1)
 // print "DS[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
				sprint(cmd, "dstellate[%d][%d].soma ds2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR, thresh,param.delay.getval(ds,ts), param.w.getval(ds,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
  outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
  }
  }
        p = 100*(channel)/(nchannels)
    printf("\rDS->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rDS->TS=== done ===\n")
}
flushf()	


if( ( param.n.getval(glg,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nGperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",glg,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(glg,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(glg,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
   if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1

    //Choose random source from available cells
    source = random.discunif(0,nGperchannel-1)
 // print "GLG[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
   if (LSR2GLG ==1 ) { //Conductance model of golgi
	   sprint(cmd, "golgi[%d][%d].soma glg2tsGABAlist.append( new NetCon(&v(0.5),tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   } else { //filter based model of golgi
		   sprint(cmd, "glg2tsGABAlist.append( new NetCon( golgi[%d][%d].sg, tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
   }
     outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
  }
  }
        p = 100*(channel)/(nchannels)
    printf("\rGLG->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rGLG->TS=== done ===\n")
}


	outfile.close()
flushf()	
}


proc TSPanel(){
  xpanel("TStellate")
  xvalue("param.ts_gnabar")
  xvalue("param.ts_gkhtbar")
  xvalue("param.ts_gleak")
  xvalue("param.ts_erev")
  xvalue("param.ts_ghbar")
  xvalue("param.ts_gkabar")

  xvalue("param.w.x[hsr][ts]")
  xvalue("param.w.x[lsr][ts]")
  xvalue("param.w.x[ds][ts]")
  xvalue("param.w.x[tv][ts]")
  xvalue("param.w.x[glg][ts]")
  xbutton("reset_weights()")
  xbutton("refresh_TStellate()")

  xbutton("CS_data","CS_data()")
  xbutton("CT1_data","CT1_data()")
  xbutton("CT2_data","CT2_data()")
//  xbutton("Plot Fit graph","plot_fitgr()")

  xbutton("Run TS model","RunTStellate()")
  xbutton("Run Fitting Procedure","runprax()")
  xbutton("QuickRun","QuickRun()")
  xvalue("PSTH resolution", "binwidth")
  xbutton("PSTH","PSTHcell(tstellate_spikes,binwidth,1)")
  xbutton("Print PSTH","PSTHcell(tstellate_spikes,binwidth,2)")
  xpanel()
}


proc TS_optim_param_Panel(){
  xpanel("TStellate Optimisation Param")
  xvalue("NPARAMS")
  xbutton("Reset pvec","init_params(NPARAMS)")
  xbutton("Include ts_gleak","append_gleak()")
  xbutton("Include ts_erev","append_rev_potentials()")
  xbutton("Include ts_ghbar","append_ghbar()")
  xbutton("Include ts_gkabar","append_gkabar()")
  
  xbutton("Include w.x[hsr][ts]","append_hsrts_weights()")
  xbutton("Include w.x[lsr][ts]","append_lsrts_weights()")
  xbutton("Include w.x[ds][ts]","append_dsts_weights()")
  xbutton("Include w.x[tv][ts]","append_tvts_weights()")
  xbutton("Include w.x[glg][ts]","append_glgts_weights()")
  
  xbutton("Include n.x[hsr][ts]","append_num_hsrts_connections()")
  xbutton("Include n.x[lsr][ts]","append_num_lsrts_connections()")
  xbutton("Include n.x[ds][ts]","append_num_dsts_connections()")
  xbutton("Include n.x[tv][ts]","append_num_tvts_connections()")
  xbutton("Include n.x[glg][ts]","append_num_glgts_connections()")
  
  xpanel() 
}

TS_optim_param_Panel()
TSPanel()
nrncontrolmenu()




 cfhi =40000
 cflo = 200
 ANmodel = 6
 species = 2
 
 RefreshCF()
 RefreshCNcellsCF()
 RefreshCellParams()

 CS_data()
 RefreshParameters()
 ANFilterBankRun()
 SetInputRates()

strdef datestr,grlbl
objref errorvec,tempcf,indcf,refvec,gr,ref,test,weightvec
gr = new Graph()

ref_shift=0
test_shift=0
plot_variables=0

func TStellate_err( ) {local jj,pp,xtime,error,penalty,sustainedrate,inputresistance

    //check for bad values
    for pp=0,NPARAMS-1 {
    if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
      return 1e9
    }
    }
  //print variables
  print "TStellate_err ", $1
    for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])}
  //Set the parameters (see parameters_TStellate.hoc)
  for pp=0,NPARAMS-1 {
    sprint(cmd,"%s = %g * %g ",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
    execute1(cmd)
  }
flushf()
  // if (plot_variables == 1) {
  //   tgr[0].line($&2[0], $&2[1])
  //   tgr[0].flush()
  //   tgr[1].line($&2[1], $&2[2])
  //   tgr[1].flush()
  //   doNotify()
  //   print $1, $&2[0], $&2[2], $&2[3]
  // }
  
  connect_TS(fileroot)
  RefreshCellParams() //refresh_TStellate()
  jitterdelay(param.delay.x[hsr][ts],param.ts_jitter_sd)
  RunTStellate()
    //Analyse spikes
    doNotify()
    //CNSpikes2()

  // Calculate fitness
  objref errorvec,weightvec,ref,test
  errorvec = new Vector()
  weightvec = new Vector(7,1)
  ref = new Vector(7,0)
  test = new Vector(7,0)
  
  errorvec.interpolate(tvec,ivdata[0],ivdata[1])
  
  //Calculate the IV shift in depolarisation 
  ref_shift = (errorvec.max_ind(220,250)/10) - 2.5
  test_shift = (meaniv.max_ind(220,250)/10) - 2.5
  IVMeasures(tvec,errorvec,ref,ref_shift)
  IVMeasures(tvec,meaniv,test,test_shift)
  PSTHcell(tstellate_spikes,10,1)
  test.copy(cvISI, 3, 0, 3, 1, 1)
  ref.copy(CV_data, 3, 0, 3, 1, 1)
  
  //Calculate additional penalties
  penalty =0
  sustainedrate = psth.sum(2,6)/25
  if(sustainedrate < 10) penalty += 12 - sustainedrate //penalty for lack of spikes during tone
  if(psth_checkedtrials < 0.9*reps) penalty += 5
  if(cvISI.x[0] > 0.2) penalty += 5
   if(cvISI.x[0] > 0.3) penalty += 5
  if(cvISI.x[1] > 0.5 || cvISI.x[1] == 0) penalty += 10
  if(cvISI.x[2] > 0.55 || cvISI.x[2] == 0) penalty += 10
  if(cvISI.x[3] > 0.55 || cvISI.x[3] == 0) penalty += 10
  access tstellate[whichcell][0].soma 
  inputresistance = rn() //Calculate input resistance, see Utilities.hoc   
  if(inputresistance < 30 || inputresistance > 400) penalty += 10
  //weightvec.x[0]/=10 //initial depolarisation approx -50 to -30  mV
  weightvec.x[1]*=10 //adaptation approx 0.2-0.5
  //weightvec.x[2]/=10 //post-tone hyperpolarisation approx 0 to -5 mV
  weightvec.x[3]*=200 //CV
  weightvec.x[4]*=200
  weightvec.x[5]*=200
  weightvec.x[6]*=200
  
  print error=sqrt(ref.meansqerr(test,weightvec)) + penalty
  
  	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
    }
	file.printf("%g\n",error)
	file.close()

  
    //plot the result
    // gr.erase_all()
    // errorvec.plot(gr,ivdata[0],1,1)
    // ivdata[1].plot(gr,ivdata[0],2,2)
    // sprint(grlbl,"Error = %g", a)
    // gr.label(0.65,0.85,grlbl)
    // for jj=0,NPARAMS-1{
  //   sprint(grlbl,"%s = %g", pvec_name.object(jj).s,pvec.x[jj])
  //   gr.label(0.65,0.75-0.05*jj,grlbl)
    // }
  doNotify()
    return error
}

//tstop=300
proc QuickRun(){
  set_pvec()
  pvec.printf
  print TStellate_err(0,&pvec.x[0])
}

tolerance = 0.0001
maxstepsize = 0.001
printmode = 3
strdef error_fn
error_fn = "TStellate_err"

proc runprax(){
   attr_praxis(tolerance, maxstepsize, printmode)
   fit_praxis(NPARAMS,error_fn,&pvec.x[0])
}



objref pval[NPARAMS]
proc printprax(){local pp,ii,pp2,cur_reps
//Output model data with best parameters
cur_reps = reps
reps=50
sprint(cmd,"mkdir -p %s",fileroot)
system(cmd)
reps=50
print error=TStellate_err(0,&pvec.x[0])
system("date",datestr)
sprint(fname,"%s/%s.Fit.dat",fileroot,origfileroot)
file.wopen(fname)
if (file.isopen()){
file.printf("# %s Optimisation\n",fileroot)
file.printf("# %s \n",datestr)
for pp=0,NPARAMS-1 {
file.printf("#%s = %g\t[%g,%g]\n",pvec_name.object(pp).s,pvec.x[pp]*pvec_factor.x[pp],pvec_ranges.x[pp][0],pvec_ranges.x[pp][1])
}
file.printf("# final error=%f\n",error)
//file.printf("# Principle axis matrix\n")
//for pp=0,NPARAMS-1 {
//pval[pp] = new Vector(NPARAMS)
//pval_praxis(pp,&pval[pp].x[0])
//file.printf("#\t")
//for pp2=0,NPARAMS-1 file.printf("%g\t",pval[pp].x[pp2])
//file.printf("\n")
//}
file.printf("# Time\tError Vec\t Reference Vec (mV)\n")
for ii=0,tvec.size()-1 {
file.printf("%.2f\t%.6f\t%.6f\n",tvec.x[ii],errorvec.x[ii],meaniv.x[ii])
}

file.printf("#Other values \n")
file.printf("#  spl = %g\n",spl)
file.printf("#  tonefreq = %g\n",tonefreq)
param.print2file(file,"#") //let Network Parameters print the struct
file.printf("#\n#IV Measures  Reference Test\n")
file.printf("#RMP\t%g\t%g\n", ivdata[1].mean(0,ivdata[0].indwhere(">",0)),meaniv.mean(ivdata[0].indwhere(">",-10),ivdata[0].indwhere(">",0)))
file.printf("#IVshift\t%g\t%g\n", ref_shift, test_shift)
file.printf("#IVOnset\t%g\t%g\n", ref.x[0], test.x[0])
file.printf("#IVAdaptation\t%g\t%g\n", ref.x[1], test.x[1])
file.printf("#IVOffset\t%g\t%g\n",ref.x[2], test.x[2])
file.printf("#CV0-10\t%g\t%g\n", ref.x[3], test.x[3])
file.printf("#CV10-20\t%g\t%g\n", ref.x[4], test.x[4])
file.printf("#CV20-30\t%g\t%g\n",ref.x[5], test.x[5])
file.printf("#CV30-40\t%g\t%g\n",ref.x[6], test.x[6])
}
file.close()
//Write parameters to general optimisation file
sprint(fname,"%s/pvec_%s.hoc",fileroot,origfileroot)
file.aopen(fname)
file.printf(" // %s  \n",datestr)
for pp=0,NPARAMS-1 {
file.printf("%s = %g*%g\n",pvec_name.object(pp).s,pvec.x[pp],pvec_factor.x[pp])
}
  file.printf("\n")
file.close()
reps = cur_reps
PSTHcell(tstellate_spikes,10,2)
PSTHcell(tstellate_spikes,1,2)
PSTHcell(tstellate_spikes,0.25,2)
}

