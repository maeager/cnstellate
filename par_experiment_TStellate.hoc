/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */


// CS and CT data were from Long-Evans and Hooded Wistar rats at RVEEH
// reported in \citep{PaoliniClareyEtAl:2005}

// -- Paolini, Clarey et al 2005 --
//     The following variables were measured from the average
//  intracellular profile (25 stimulus repetitions) at 30 dB (± 5 dB) above
//  the SPL that evoked voltage depolarization from the resting membrane
//   potential (RMP): (i) a measure of the level of initial depolarization was
//  given by the ratio of the depolarization occurring 5–10 ms after tone
//  onset to the average amplitude drop to sustained levels occurring 20–
//   30 ms after tone onset; (ii) a measure of the adaptation of sustained
//  depolarization during tone presentation was given by the difference in
//  depolarization amplitude at 20 ms and 50 ms after stimulus onset; (iii)
//  a measure of post-tone hyperpolarization was given by the change in
//  voltage, relative to RMP, 60 ms after stimulus onset (i.e. 10 ms after
//  tone offset). Membrane potential levels from traces calculated at
//  specific time points for variables 2 and 3 (i.e. 20, 50 and 60 ms) were
//  found by averaging the membrane potential over a 1-ms period (i.e.
//  20–21, 50–51 and 60–61 ms). Included in this sample are four
//  neurons whose responses to tones have been described previously
//  (Paolini & Clark, 1999; cell #: 98-280-003, 95-232-003, 98-257-002,
//  96-249-012). The intracellular response profile of all neurons reported
//  in this study was distinct from that of bushy cells (Paolini et al., 1997;
//  Paolini & Clark, 1999).


//   The cell’s rate-level function was then determined by presenting 50-ms CF
//  tone bursts (5 ms rise–fall time; 25–50 repetitions; 10 Hz repetition
//  frequency) in 5- or 10-dB steps from subthreshold sound pressure
//  levels (SPLs) to SPLs that produced discharge rate saturation. If
//  possible, frequency response areas were then determined by present-
//  ing tones at non-CF frequencies over a range of SPLs.
//     Acoustic stimuli were synthesized digitally and generated by a
//  Beyer DT48 transducer (Beyerdynamic, Farmingdale, NY, USA),
//  which was positioned at the end of a hollow ear bar and controlled
//  using a Tucker-Davis signal generator (Tucker-Davis Technologies,

stimdelay					= 0.05
dur						= 0.049
ramplngth				= 0.002
dutycycle				= 1        // get an extra 25msec post-tone
cfhi					= 40000
cflo					= 200
srate					= 100000      // 500k is no longer needed
stimtdres				= 1/srate
sg_rate					= 20000
sg_tdres				= 1/sg_rate
tstop					= 110
ANmodel					= 6
species					= 2 //Rat
audiogram_file			= "rat_bruce_audiogram.dat"
reps					= 25
usesavedfilterbanks		= 1


RefreshCF()
GetAudiogramData()

objref tempmat, ivdata[2], chopperIVgr,chopperCVgr
objref CV_sustained, CV_transient1, CV_transient2, CV_data
proc ChopperCVData(){local nrow,ncol
nrow					= 5
ncol					= 3
objref CV_sustained, CV_transient1, CV_transient2
CV_transient2			= new Matrix()
CV_transient1			= new Matrix()
CV_sustained			= new Matrix()

file					= new File()
file.ropen("TStellate/PaoliniBalancedInh-Fig2.png.dat")
if(file.isopen()){
CV_transient2.scanf(file,nrow, ncol)
CV_transient1.scanf(file,nrow, ncol)
CV_sustained.scanf(file,nrow, ncol)
file.close()
} else {
print "Error reading CV data"
}
}

//ChopperCVData()


proc CalcIVMeasures(){

    onset_depol = $o1.mean(ivdata[0].indwhere(">=",5.0), ivdata[0].indwhere(">=",10.0))
    middle_depol = $o1.mean( ivdata[0].indwhere(">=",20), ivdata[0].indwhere(">=",30))

    onset_ratio = onset_depol / middle_depol

    v20_depol = $o1.mean( ivdata[0].indwhere(">=",20) - 1, ivdata[0].indwhere(">=",21))
    v50_depol = $o1.mean( ivdata[0].indwhere(">=",50) -1, ivdata[0].indwhere(">=",51))
    adaptation_ratio = v20_depol - v50_depol

    resting_value  = $o1.mean(0 , ivdata[0].indwhere(">",0))
    v60_depol = $o1.mean(ivdata[0].indwhere(">=",60) - 1, ivdata[0].indwhere(">=",61))
    offset_hyperpol = resting_value - v60_depol

    print "resting membrane potential              ", resting_value
    print "level of initial depolarization         ", onset_depol
    print "adaptation of sustained depolarization  ", adaptation_ratio
    print "post-tone hyperpolarization             ", offset_hyperpol

}


proc CS_data() {local points
   //chopper sustained
   // unit 01-864-004
   //CV (10ms segs) always below 0.2 for 45, 65, and 75 dB
   // rate saturation at 75 dB
   // depolarisation threshold 10dB
   spl      = 40   //30 dB above depolarisation threshold
   tonefreq = 3900 //Hz, characteristic frequency
   whichcell = FindInd(tonefreq)  //get CF index close to 3.9kHz
   print "CS data CF ", tonefreq, "(Hz), location ", whichcell

   objref tempmat, ivdata[2]
   ivdata[0] = new Vector()
   ivdata[1] = new Vector()

   file.ropen("TStellate/CS-01-864-004.png.dat")

   tempmat = new Matrix()
   tempmat.scanf(file)
   ivdata[0] = tempmat.getcol(0) //time
   ivdata[1] = tempmat.getcol(1) //voltage (mV)
   file.close()
   chopperIVgr =  new Graph()
   ivdata[1].plot(chopperIVgr,ivdata[0])
   chopperIVgr.exec_menu("View = plot")
   sprint(fileroot,"TStellate_CS")    // root for output filenames
  CalcIVMeasures(ivdata[1])
  ChopperCVData()
  CV_data = CV_sustained.getcol(1).c
}

proc CT1_data() {local points

   // chopper transient 1
   // unit 01-857-007 \citep{PaoliniClareyEtAl:2005}
   // CV first 10ms <0.2, then moves above 0.2
   // this unit's depolarisation threshold  55 dB
   // average CT threshold for depolarization
   // and AP generation of 47.2 ± 2.5 and 57.4 ± 2.2 dB SPL

   spl      = 85   //30 dB above depolarisation threshold
   tonefreq = 8200 //Hz, characteristic frequency
   whichcell = FindInd(tonefreq)  //get CF index close to 8.2kHz
   print "CT1 data CF ", tonefreq, "(Hz), location ", whichcell
   file.ropen("TStellate/CT1-01-857-007.png.dat")
   objref tempmat, ivdata[2]
   ivdata[0] = new Vector()
   ivdata[1] = new Vector()
   tempmat = new Matrix() //points, 2)
   tempmat.scanf(file)
   ivdata[0] = tempmat.getcol(0) //time
   ivdata[1] = tempmat.getcol(1) //voltage (mV)
   file.close()
   chopperIVgr =  new Graph()
   ivdata[1].plot(chopperIVgr,ivdata[0])
   chopperIVgr.exec_menu("View = plot")
  sprint(fileroot,"TStellate_CT1")    // root for output filenames
  CalcIVMeasures(ivdata[1])
  ChopperCVData()
  CV_data = CV_transient1.getcol(1).c

}

proc CT2_data() {local points

   //chopper transient type 2
   // unit 01-305-014 \citep{PaoliniClareyEtAl:2005}
   //CV (10ms segs) first 10m below 0.2, then rises above 0.3
   // rate saturation at 5 dB
   spl      = 35   //30 dB above depolarisation threshold
   tonefreq = 12400 //Hz
   whichcell = FindInd(tonefreq)  //get CF index close to 12.4kHz
   file.ropen("TStellate/CT2-01-305-014.png.dat")
   print "CT2 data CF ", tonefreq, "(Hz), location ", whichcell

   objref tempmat, ivdata[2]
   ivdata[0] = new Vector()
   ivdata[1] = new Vector()
   tempmat = new Matrix() //points, 2)
   tempmat.scanf(file)
   ivdata[0] = tempmat.getcol(0) //time
   ivdata[1] = tempmat.getcol(1) //voltage (mV)
   file.close()
   chopperIVgr =  new Graph()
   ivdata[1].plot(chopperIVgr,ivdata[0])
   chopperIVgr.exec_menu("View = plot")
   sprint(fileroot,"TStellate_CT2")    // root for output filenames
  CalcIVMeasures(ivdata[1])
  ChopperCVData()
  CV_data = CV_transient2.getcol(1).c

}









CT1_data()


//RefreshParameters()    //Generate or get stim from file
//ANFilterBankRun()

binwidth=0.5
objref iv,meaniv,psthgr,tstellate_spikes
psthgr = new Graph()

proc RunTStellate(){
    objref iv,meaniv,tvec
//    ClearSpikes()
    iv = new Vector()
    iv.record(&tstellate[whichcell][0].soma.v(0.5))
    meaniv = new Vector(tstop/dt + 1,0)
    //tstellate[whichcell][0].spikes.resize(0)
	tstellate_spikes = new List()
    for ireps = 0, reps-1 {
        GenSpikes2()
        print ireps
        run()
        //SaveSpikes()
        tstellate_spikes.append(tstellate[whichcell][0].spiketimes.c)
        for i=0,tstop/dt-1{
         if (iv.x[i] > thresh) iv.x[i] = thresh
        }
        meaniv.add(iv)
        iv.mul(0)
    }
    meaniv.div(reps)
    tvec=new Vector(tstop/dt + 1)
    tvec.indgen(dt).add(-20)
    meaniv.plot(chopperIVgr,tvec)

    chopperIVgr.exec_menu("View = plot")
  CalcIVMeasures(ivdata[1])
  CalcIVMeasures(meaniv)
  //psth = tstellate[whichcell][0].spikes.histogram(0,110,binwidth)
  //psth.plot(psthgr,binwidth) psthgr.exec_menu("View = plot")
  PSTHcell(tstellate_spikes,10,1)
}

param.ts_gnabar						= 0.23677
param.ts_gkhtbar					= 0.0189416
param.ts_gleak						= 0.000473539
param.ts_erev						= -55
param.ts_ghbar						= 6.20392e-05
param.ts_gkabar						= 0.01539

proc refresh_TStellate(){local ii,jj
    print "updating features for T stellate optimisation routines"
    for ii = 0,nchannels-1 {
		for jj=0,nTSperchannel-1{
			//        if(ii == 20 || ii == 38 || ii == 51){
			sprint(cmd,"tstellate[%d][%d].soma.gnabar_rm  = param.ts_gnabar",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.gkhtbar_rm = param.ts_gkhtbar",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.gleak_rm   = param.ts_gleak",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.erev_rm    = param.ts_erev",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.ghbar_rm   = param.ts_ghbar",ii,jj) execute1(cmd)
			sprint(cmd,"tstellate[%d][%d].soma.gkabar_ka  = param.ts_gkabar",ii,jj) execute1(cmd)
			flushf()
		}
	}
}


proc IVMeasures(){local offset
    /// args: 1 time vec, 2 voltage vec, 3 output vec (size=6), 4 offset
	if (numarg() != 4) {
		offset = 0
	} else {
		offset = $4
	}
    onset_depol = $o2.mean($o1.indwhere(">=",5.0+offset), $o1.indwhere(">=",10.0+offset))
    middle_depol = $o2.mean( $o1.indwhere(">=",20+offset), $o1.indwhere(">=",30+offset))
    onset_ratio = onset_depol / middle_depol

    v20_depol = $o2.mean( $o1.indwhere(">=",20+offset) - 1, $o1.indwhere(">=",22+offset))
    v50_depol = $o2.mean( $o1.indwhere(">=",50+offset) - 1, $o1.indwhere(">=",52+offset))
    adaptation_ratio = v20_depol - v50_depol

    resting_value  = $o2.mean($o1.indwhere(">",-10) , $o1.indwhere(">",0))
    v60_depol  = $o2.mean($o1.indwhere(">=",60+offset) - 1, $o1.indwhere(">=",65+offset))
    offset_hyperpol = resting_value - v60_depol

    $o3.x[0] = onset_ratio
    $o3.x[1] = adaptation_ratio
    $o3.x[2] = offset_hyperpol
	print "resting membrane potential              ", resting_value
	print "level of initial depolarization         ", onset_ratio
	print "adaptation of sustained depolarization  ", adaptation_ratio
	print "post-tone hyperpolarization             ", offset_hyperpol
	
}



//mimick connect_CNcells from CochlearNucleus.hoc
proc connect_TS() {local i,p,target,source,low,high,range,channel,sourcechannel
	
	objref tstellate[nchannels][nTSperchannel]
	
  for i_chan = 0, nchannels-1 {
    if (nTSperchannel > 0) for j_cell = 0, nTSperchannel-1 {
        sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d,1)",i_chan,j_cell,i_chan,i_chan)
        execute1(cmd)
    }
}	
flushf()

	
	
	
	print "Connecting cells."
	sprint(filename,"%s.connect",$s1)
	outfile.wopen(filename)
	
	
	objref 	hsr2tsAMPAlist,	lsr2tsAMPAlist,	glg2tsGABAlist,	ds2tsGLYlist,	tv2tsGLYlist,	ts2tsAMPAlist
	
	hsr2tsAMPAlist = new List()
	lsr2tsAMPAlist = new List()
	glg2tsGABAlist = new List()
	ds2tsGLYlist  = new List() 
	tv2tsGLYlist  = new List() 
	ts2tsAMPAlist  = new List()
	
	

if( ( param.n.getval(hsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
outfile.printf("\n%d %d\n",hsr,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(hsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(hsr,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells in sourcechannel
    source = random.discunif(0,HSRsperchannel-1)
	//print "HSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
	sprint(cmd, "tstellate[%d][%d].soma hsr2tsAMPAlist.append( new NetCon( an.HSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(hsr,ts), param.w.getval(hsr,ts)))",channel,target,sourcechannel,source,channel,target)
	execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
	outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\rHSR->TS === %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
 printf("\rHSR->TS === done ===\n")
}

if( ( param.n.getval(lsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",lsr,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(lsr,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(lsr,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,LSRsperchannel-1)
 //print "LSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
 sprint(cmd, "tstellate[%d][%d].soma lsr2tsAMPAlist.append( new NetCon( an.LSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ts), param.w.getval(lsr,ts)))",channel,target,sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
  outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
    p = 100*(channel)/(nchannels)
    printf("\rLSR->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
 printf("\rLSR->TS=== done ===\n")
}
flushf()	
	
	
	print "Connecting CN network cells to TS cells"
	
	
if( ( param.n.getval(ts,ts) > 0 ) && ( nTSperchannel > 1 ) ){
 outfile.printf("%d %d\n",ts,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(ts,ts)-1{
    //Choose random source from available cells
    source = random.discunif(0,nTSperchannel-1)
    while( source == target)  source = random.repick()  //Don't connect to self
 // print "TS[",channel,"][",source,"] connected to "TS[",channel,"][",target,"]"
 // tscells[channel*numTSperchannel+target].connect_pre(tscells[source], 1, param.delay.getval(ts,ts), param.w.getval(ts,ts))
 sprint(cmd, "tstellate[%d][%d].soma ts2tsAMPAlist.append( new NetCon(&v(0.5), tstellate[%d][%d].AMPA, thresh,param.delay.getval(ts,ts), param.w.getval(ts,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
    outfile.printf("%d %d %d %d\n",channel,source,channel,target)

   }
  }
        p = 100*(channel)/(nchannels)
    printf("\rTS->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rTS->TS=== done ===\n")
}
flushf()	


if( ( param.n.getval(tv,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nTVperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",tv,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(tv,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(tv,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nTVperchannel-1)
 // print "TV[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
				sprint(cmd, "tuberculoventral[%d][%d].soma tv2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR,  thresh,param.delay.getval(tv,ts), param.w.getval(tv,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)

   }
  }
        p = 100*(channel)/(nchannels)
    printf("\rTV->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rTV->TS=== done ===\n")
}
flushf()	

if( ( param.n.getval(ds,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nDSperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",ds,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(ds,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(ds,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nDSperchannel-1)
 // print "DS[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
				sprint(cmd, "dstellate[%d][%d].soma ds2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR, thresh,param.delay.getval(ds,ts), param.w.getval(ds,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
  outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
  }
  }
        p = 100*(channel)/(nchannels)
    printf("\rDS->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rDS->TS=== done ===\n")
}
flushf()	


if( ( param.n.getval(glg,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nGperchannel != 0 ) ){
 outfile.printf("\n%d %d\n",glg,ts)
 for channel = 0, nchannels-1{
  for target = 0, nTSperchannel-1 {
   for i=0, param.n.getval(glg,ts)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(glg,ts)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
   if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1

    //Choose random source from available cells
    source = random.discunif(0,nGperchannel-1)
 // print "GLG[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
   if (LSR2GLG ==1 ) { //Conductance model of golgi
	   sprint(cmd, "golgi[%d][%d].soma glg2tsGABAlist.append( new NetCon(&v(0.5),tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
   } else { //filter based model of golgi
		   sprint(cmd, "glg2tsGABAlist.append( new NetCon( golgi[%d][%d].sg, tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
        execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
   }
     outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
  }
  }
        p = 100*(channel)/(nchannels)
    printf("\rGLG->TS=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\rGLG->TS=== done ===\n")
}


	outfile.close()
flushf()	
}

