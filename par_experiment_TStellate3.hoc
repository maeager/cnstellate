/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/*  par_experiment_TStellate3
*  Experimental setup for second TStellate optimisation 
*
*   
*    Copyright © 2012 Michael Eager, (mick.eager@gmail.com)
* 
*    This file is part of cnstellate.
* 
*    This is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
*/


// CS and CT data were from Long-Evans and Hooded Wistar rats at RVEEH
// reported in \citep{PaoliniClareyEtAl:2005}:
//  The cell’s rate-level function was then determined by presenting 50-ms CF
//  tone bursts (5 ms rise–fall time; 25–50 repetitions; 10 Hz repetition
//  frequency) in 5- or 10-dB steps from subthreshold sound pressure
//  levels (SPLs) to SPLs that produced discharge rate saturation. If
//  possible, frequency response areas were then determined by present-
//  ing tones at non-CF frequencies over a range of SPLs.
//     Acoustic stimuli were synthesized digitally and generated by a
//  Beyer DT48 transducer (Beyerdynamic, Farmingdale, NY, USA),
//  which was positioned at the end of a hollow ear bar and controlled
//  using a Tucker-Davis signal generator (Tucker-Davis Technologies,


// Issues with simulated model and experimental data:

// Mean RMP and AP in CS/CT rat neurons Paolini et al 2004:
// average resting potentials (-60.9 ± 1.4 mV), AP heights
// (39.8 ± 1.9 mV), and CFs (9.1 ± 1.0 kHz), OC neurons had
// significantly higher depolarization and AP thresholds than CS/T
// neurons. Specifically, the minimal SPLs that evoked depolar-
// ization in CS/T and OC neurons were 31.7 ± 2.9 and 45.6 ± 2.7
// dB, respectively (t25 = 3.02, P < 0.05), and the minimal SPLs
// that evoked AP generation were 41.8 ± 3.8 and 56.6 ± 2.2 dB,
// respectively (t25 = 2.5, P < 0.05).

TSexemplar_RMP = -60.9
TSexemplar_SPL_thresh = 40
TSexemplar_CF = 9100


// Differences in the extent of hyperpolarization in
// the identified stellate cell groups can not be attributed to differences in
// RMP because there was no significant difference in this measure
// between groups (F3,40 1⁄4 0.2, P > 0.05). The mean RMP (± SEM) for
// OC, CT1, CT2 and CS cells was: -61.9 ± 1.7, -60.2 ± 1.9, -59.0 ± 1.9
// and -58.7 ± 2.8 mV, respectively.

func SetChopperRMP(){
	if ($1 == 0) {
		return -58.7
	} else if ($1 == 1) {
		return -60.2
	}else if ($1 == 2 ) {
		return -59.0
	}
	print "SetChopperRMP: Using default TS RMP"
	return TSexemplar_RMP   
}



// CV classification (Paolini et al 2004,2005):
// Young et al. 1988). This measure differentiates between two chopper
// subtypes, both of which are recorded from T stellate cells. Neurons
// with low, consistent CV values (< 0.2) were classified as CS, while CT
// neurons were those with an initial, low CV (< 0.2) that increased
// during the tone (0.2 < CV < 0.5). Contour plots derived from the
// average intracellular traces over 25 stimulus repetitions were used to
// examine the relationship between stimulus SPL and membrane po-
// tential during CF tone presentation. 

proc TS3_stimulus_setup(){
	
	stimdelay               = 0.05
	dur                  = 0.0475    // Actual duration minus half ramplength
	ramplngth            = 0.005 
	dutycycle            = 0.8       // get an extra 40msec post-tone
	cfhi               = 40000     //suitable for cat and rat model but not for human
	cflo               = 200       
	srate               = 100000    // 500k is no longer needed in Zilany AN model
	stimtdres            = 1/srate
	sg_rate               = 50000     // store AN model at 50k 
	sg_tdres            = 1/sg_rate
	tstop               = 180       // 50 ms delay, 50 ms stim, 40 ms post tone
	ANmodel               = 7         // ZilanyBruce
	species               = 9         //Cat
	audiogram_file         = "cat_audiogram.txt"
	reps               = 25
	usesavedfilterbanks      = 1
	RefreshCF()
	GetAudiogramData()
}
TS3_stimulus_setup()



// Reference and test comparison vectors: These objects are lists with three
// pointers to vectors (each with only 4 members).  The first object is 20 dB re
// threshold, second 30 dB, and third 40 dB.
// The IV vectors contain the onset ratio, the adaptation shift, the offset shift  (and the RMP although this is not compared).
// The CV vectors contain the CV calculations in 10 ms intervals in the stimulus  i.e.  0-10, 10-20, 20-30, and 30-40.
// The weight vectors are used to eliminate unused data and emphasise important comparisons.
objref IV_reference,CV_reference,IV_weight,CV_weight


//temporary variables and objects
objref tempmat, ivdata[2]
objref chopperIVgr,chopperCVgr
objref CV_sustained, CV_transient1, CV_transient2, CV_data
objref CVdata_CS, CVlevel_CS


strdef datestr,grlbl
objref errorvec,tempcf,indcf,gr
objref refvec,ref,test,weightvec
gr = new Graph()

ref_shift=0
test_shift=0
plot_variables=0

// retain IV traces and spikes between simulations at each level
objref TSIVList,TSspikeList


proc SetupChopperCV(){local nrow,ncol
	nrow   = 5
	ncol   = 3
	
	objref CV_sustained, CV_transient1, CV_transient2
	CV_transient2         = new Matrix()
	CV_transient1         = new Matrix()
	CV_sustained         = new Matrix()
	
	file = new File()
	file.ropen("TStellate/PaoliniBalancedInh-Fig2.png.dat")
	if(file.isopen()){
		CV_transient2.scanf(file,nrow, ncol)
		CV_transient1.scanf(file,nrow, ncol)
		CV_sustained.scanf(file,nrow, ncol)
		file.close()
	} else {
		print "Error reading TStellate/PaoliniBalancedInh-Fig2.png.dat"
	}
	
	// CV at 3 levels for CS unit in Figure 3C (20,40,50 dB re Thresh)
	file.ropen("TStellate/Paolini2005_Fig3C_CVdata.dat")
	if(file.isopen()){
		CVdata_CS = new Matrix()
		CVdata_CS.scanf(file,5, 4)
		file.close()
		CVlevel_CS = new Vector()
		//SPL values in Figure 3,  re threshold
		CVlevel_CS.append(20,40,50)
	} else {
		print "Error reading CV data TStellate/Paolini2005_Fig3C_CVdata.dat"
	}
	
}

SetupChopperCV()

// MP Statistics -- Paolini, Clarey et al 2005 --
//     The following variables were measured from the average
//  intracellular profile (25 stimulus repetitions) at 30 dB (± 5 dB) above
//  the SPL that evoked voltage depolarization from the resting membrane
//   potential (RMP): (i) a measure of the level of initial depolarization was
//  given by the ratio of the depolarization occurring 5–10 ms after tone
//  onset to the average amplitude drop to sustained levels occurring 20–
//   30 ms after tone onset; (ii) a measure of the adaptation of sustained
//  depolarization during tone presentation was given by the difference in
//  depolarization amplitude at 20 ms and 50 ms after stimulus onset; (iii)
//  a measure of post-tone hyperpolarization was given by the change in
//  voltage, relative to RMP, 60 ms after stimulus onset (i.e. 10 ms after
//  tone offset). Membrane potential levels from traces calculated at
//  specific time points for variables 2 and 3 (i.e. 20, 50 and 60 ms) were
//  found by averaging the membrane potential over a 1-ms period (i.e.
//  20–21, 50–51 and 60–61 ms). Included in this sample are four
//  neurons whose responses to tones have been described previously
//  (Paolini & Clark, 1999; cell #: 98-280-003, 95-232-003, 98-257-002,
//  96-249-012). The intracellular response profile of all neurons reported
//  in this study was distinct from that of bushy cells (Paolini et al., 1997;
//  Paolini & Clark, 1999).

// Modifications to the AIV statistics -- Michael Eager
// sampling periods increased from 1 msec to 5 msec

// Membrane potential adaptation and hyperpolarisation
// data from Figure 6 in Paolini et al. 2005
// MP*_data will be used in the optimation routine
// Average of 10 CT1, 4 CT2  units
// Note: no CS unit average only single unit at levels other than 30 dB re threshold 
objref MPadaptation_CS, MPadaptation_CT1, MPadaptation_CT2, MPadaptation_data
objref MPhyper_CS, MPhyper_CT1, MPhyper_CT2, MPhyper_data, MPlevel_re_thresh

proc SetupChopperMP(){local nrow,ncol
	objref MPadaptation_CS, MPadaptation_CT1, MPadaptation_CT2, MPadaptation_data
	objref MPhyper_CS, MPhyper_CT1, MPhyper_CT2, MPhyper_data
	
	nrow = 4 // four SPL levels
	ncol = 3 // SPL, Adaptation or Offset difference mean , standard deviation
	
	MPadaptation_CS = new Matrix()
	MPadaptation_CT1 = new Matrix()
	MPadaptation_CT2 = new Matrix()
	
	MPhyper_CS = new Matrix()
	MPhyper_CT1 = new Matrix()
	MPhyper_CT2 = new Matrix()
	MPlevel_re_thresh = new Vector()
	MPlevel_re_thresh.append(10,20,30,40)
	
	// CT 1 & 2 adaptation 
	file = new File()
    file.ropen("TStellate/Fig6A.dat")
	if(file.isopen()){
		MPadaptation_CT2.scanf(file,nrow, ncol)
		MPadaptation_CT1.scanf(file,nrow, ncol)
		MPadaptation_CS = new Matrix(nrow,ncol)
		MPadaptation_CS.zero()
		file.close()
	} else {
		print "Error reading MP data"
	}
	
	//CT 1 & 2 hyperpolarisation
	file.ropen("TStellate/Fig6B.dat")
	if(file.isopen()){
		MPhyper_CT2.scanf(file,nrow, ncol)
		MPhyper_CT1.scanf(file,nrow, ncol)
		file.close()
	} else {
		print "Error reading MP data Fig6B.dat"
	}
	
	// CS unit 01-859-013
	// Figure 3, Paolini et al., 2005
	// Hyperpolarisation MPt60 - RMP
	file.ropen("./TStellate/PaoliniBalancedInh_Fig3_Offset.dat")
	if(file.isopen()){
		MPhyper_CS = new Matrix()
		MPhyper_CS.scanf(file,4, 4)
		file.close()
	} else {
		print "Error reading MP data PaoliniBalancedInh-Fig3_Offset.dat"
	}
	
	
}

SetupChopperMP()



proc CalcIVMeasures(){
	
    onset_depol = $o1.mean(ivdata[0].indwhere(">=",5.0), ivdata[0].indwhere(">=",10.0))
    middle_depol = $o1.mean( ivdata[0].indwhere(">=",20), ivdata[0].indwhere(">=",30))
	
    onset_ratio = onset_depol / middle_depol
	
    v20_depol = $o1.mean( ivdata[0].indwhere(">=",20) - 1, ivdata[0].indwhere(">=",21))
    v50_depol = $o1.mean( ivdata[0].indwhere(">=",50) -1, ivdata[0].indwhere(">=",51))
    adaptation_ratio = v20_depol - v50_depol
    
    resting_value  = $o1.mean(0 , ivdata[0].indwhere(">",0))
    v60_depol = $o1.mean(ivdata[0].indwhere(">=",60) - 1, ivdata[0].indwhere(">=",61))
    offset_hyperpol = resting_value - v60_depol
	
    print "resting membrane potential              ", resting_value
    print "level of initial depolarization         ", onset_depol
    print "onset ratio                             ", onset_ratio
	
    print "adaptation of sustained depolarization  ", adaptation_ratio
    print "post-tone hyperpolarization             ", offset_hyperpol
    
}


proc CalcIVMeasures_version2(){local time_shift localobj iv_vec,time_vec
    iv_vec=$o1
    time_vec=$o2
    if (numarg()==3) { 
		time_shift= $3 
	} else {
		time_shift = 0
	}
    
    onset_depol = iv_vec.mean(time_vec.indwhere(">=",5.0+time_shift), time_vec.indwhere(">=",10.0+time_shift))
    
    middle_depol = iv_vec.mean( time_vec.indwhere(">=",20+time_shift), time_vec.indwhere(">=",30+time_shift))
	
    onset_ratio = onset_depol / middle_depol
	
    v20_depol = iv_vec.mean( time_vec.indwhere(">=",18+time_shift) - 1, time_vec.indwhere(">=",23+time_shift))
    v50_depol = iv_vec.mean( time_vec.indwhere(">=",40+time_shift) - 1, time_vec.indwhere(">=",45+time_shift))
    adaptation_ratio = v20_depol - v50_depol
    
    resting_value  = iv_vec.mean(0 , time_vec.indwhere(">",0))
    v60_depol = iv_vec.mean(time_vec.indwhere(">=",58+time_shift) - 1, time_vec.indwhere(">=",63+time_shift))
    offset_hyperpol = resting_value - v60_depol
    
    print "resting membrane potential              ", resting_value
    print "time shift                              ", time_shift
    print "level of initial depolarization         ", onset_depol
    print "IV STAT 1 onset ratio                   ", onset_ratio  
    print "IV STAT 2 adaptation of depolarization  ", adaptation_ratio
    print "IV STAT 3 post-tone hyperpolarization   ", offset_hyperpol
}



objref IV_temp,IV_reference,CV_reference,CV_temp,ref_IVvec
objref IV_weight,CV_weight // set the RMS error weighting, set to zero if no reference data

default_CV_weight=100
sustained_transient_chopper=0


proc CS_data() {local points
	//chopper sustained
	// unit 01-864-004  CF 11.7kHz  AP threshold 10 dB
	//CV (10ms segs) always below 0.2 for 45, 65, and 75 dB
	// rate saturation at 75 dB
	// threshold 10dB
	//spl      = 40   //30 dB above depolarisation threshold
	//tonefreq = 11700 //Hz, characteristic frequency
	
	spl = TSexemplar_SPL_thresh
	tonefreq = TSexemplar_CF
	
	sprint(fileroot,"TStellate3_CS")    // root for output filenames
	sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	
	TS3_stimulus_setup()
	
	
	whichcell = FindInd(tonefreq)  //get CF index close to tonefreq
	print "CS data CF ", tonefreq, "(Hz), location ", whichcell
	
	objref tempmat, ivdata[2]
	ivdata[0] = new Vector() //time vector
	ivdata[1] = new Vector() //iv trace vector
	
	//Get iv trace from Figure 1A (Paolini et al 2005)
	// spl=40 dB in figure
	file.ropen("TStellate/CS-01-864-004.png.dat")
	tempmat = new Matrix()
	tempmat.scanf(file)
	ivdata[0] = tempmat.getcol(0) //time
	ivdata[1] = tempmat.getcol(1) //voltage (mV)
	file.close()
	chopperIVgr =  new Graph()
	ivdata[1].plot(chopperIVgr,ivdata[0])
	chopperIVgr.exec_menu("View = plot")
	
	
	IV_reference = new List()
	IV_weight = new List()
	//10 dB re thresh
	//IV_temp = new Vector(4,0)   
	//IV_reference.append(IV_temp) //No data
	//IV_weight.append(IV_temp)
	
	//20 dB re thresh
	IV_temp = new Vector(4,0)
	IV_temp.x[2] = MPhyper_CS.x[0][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CS.x[0][2] //RMP
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison
	IV_weight.append(IV_temp)
    
	//30 dB re thresh  (use actual trace in Figure 1)
	IV_temp = new Vector()
	CalcIVMeasures_version2(ivdata[1],ivdata[0])
	IV_temp.append(onset_ratio,adaptation_ratio ,offset_hyperpol,resting_value)    
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,1)
	IV_temp.x[3]=0  // ignore RMP
	IV_weight.append(IV_temp) //all data available
	
	
	
	//40 dB re thresh
	IV_temp = new Vector(4)   
	IV_reference.append(IV_temp)
	IV_temp.x[2] = MPhyper_CS.x[2][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CS.x[2][2] //RMP
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison   
	IV_weight.append(IV_temp)
	
	
	SetupChopperCV()
	CV_reference = new List()
	CV_weight = new List()
	
	//10 dB re thresh
	//CV_temp = new Vector()   
	//CV_reference.append(CV_temp) //No data
    
	//20 dB re thresh  (remove the last elementin CVdata_CS)
	CV_reference.append(CVdata_CS.getcol(1).remove(4))
	CV_temp = new Vector(4,default_CV_weight)
	CV_weight.append(CV_temp)
	
	
	//30 dB - Average data in Figure 2 
	CV_temp = CV_sustained.getcol(1).c
	CV_reference.append(CV_temp.remove(4))
	CV_temp = new Vector(4,default_CV_weight*2)
	CV_weight.append(CV_temp)
	
	
	//40 dB re thresh
	CV_temp = new Matrix()
	CV_reference.append(CVdata_CS.getcol(2).remove(4))
	CV_temp = new Vector(4,default_CV_weight)
	CV_weight.append(CV_temp)
	
	sustained_transient_chopper=0
	
}

proc Test_IVCV_reference_data(){local ii
	for ii=0,2 {
		print "ii  ", ii   
		CV_reference.object(ii).printf
		CV_weight.object(ii).printf
		print ""  
		IV_reference.object(ii).printf
		IV_weight.object(ii).printf
	}
}

proc CT1_data() {local points localobj temp
	
	// chopper transient 1 CF 8.2 KHz
	// unit 01-857-007 \citep{PaoliniClareyEtAl:2005}
	// CV first 10ms <0.2, then moves above 0.2
	// this unit's depolarisation threshold  55 dB
	// average CT threshold for depolarization
	// and AP generation of 47.2 ± 2.5 and 57.4 ± 2.2 dB SPL
	
	//spl      = 85   //30 dB above depolarisation threshold
	//tonefreq = 8200 //Hz, characteristic frequency
    spl = TSexemplar_SPL_thresh
    tonefreq = TSexemplar_CF
	TS3_stimulus_setup()
	
	
	whichcell = FindInd(tonefreq)  //get CF index close to 8.2kHz
	print "CT1 data CF ", tonefreq, "(Hz), location ", whichcell
	sprint(fileroot,"TStellate3_CT1")    // root for output filenames    
	sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	
	file.ropen("TStellate/CT1-01-857-007.png.dat")
	objref tempmat, ivdata[2]
	ivdata[0] = new Vector()
	ivdata[1] = new Vector()
	tempmat = new Matrix() //points, 2)
	tempmat.scanf(file)
	ivdata[0] = tempmat.getcol(0) //time
	ivdata[1] = tempmat.getcol(1) //voltage (mV)
	file.close()
	chopperIVgr =  new Graph()
	ivdata[1].plot(chopperIVgr,ivdata[0])
	chopperIVgr.exec_menu("View = plot")
	
	
	
	IV_reference = new List()
	IV_weight = new List()
	//10 dB re thresh
	//IV_temp = new Vector(4,0)   
	//IV_reference.append(IV_temp) //No data
	//IV_weight.append(IV_temp)
	
	//20 dB re thresh
	IV_temp = new Vector(4,0)
	IV_temp.x[1] = MPadaptation_CT1.x[1][1]
	IV_temp.x[2] = MPhyper_CT1.x[1][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT1.x[1][2] //s.e.
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  //  
	IV_weight.append(IV_temp)
    
	//30 dB re thresh  (use actual trace in Figure 1)
	IV_temp = new Vector()
	CalcIVMeasures_version2(ivdata[1],ivdata[0])
	IV_temp.append(onset_ratio,adaptation_ratio ,offset_hyperpol,resting_value)    
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,1)
	IV_temp.x[3]=0  // ignore RMP
	IV_weight.append(IV_temp) //all data available
	
	
	
	//40 dB re thresh
	IV_temp = new Vector(4)   
	IV_reference.append(IV_temp)
	IV_temp.x[1] = MPadaptation_CT1.x[1][1]
	IV_temp.x[2] = MPhyper_CT1.x[2][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT1.x[2][2] //s.e. of hyperpolarisation
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison   
	IV_weight.append(IV_temp)
	
	
	
	//CV
	SetupChopperCV()
	CV_reference = new List()
	CV_weight = new List()
	
	CV_temp = CV_transient1.getcol(1).c   
	CV_temp.remove(4)
	
	//10 dB re thresh
	//CV_temp = new Vector()   
	//CV_reference.append(CV_temp) //No data
    
	//20 dB re thresh  (remove the last elementin CVdata_CS)
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)
	
	
	//30 dB - Average data in Figure 2 
	CV_reference.append(CV_temp)   
	temp = new Vector(4,default_CV_weight*2)
	CV_weight.append(temp)
	
	
	//40 dB re thresh
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)
	
	sustained_transient_chopper=1
    
}

proc CT2_data() {local points localobj temp
	
	//chopper transient type 2
	// unit 01-305-014 \citep{PaoliniClareyEtAl:2005}
	//CV (10ms segs) first 10m below 0.2, then rises above 0.3
	// rate saturation at 5 dB
	// spl      = 35   //30 dB above depolarisation threshold
	// tonefreq = 12400 //Hz
	spl = TSexemplar_SPL_thresh
	tonefreq = TSexemplar_CF
	TS3_stimulus_setup()	
	sprint(fileroot,"TStellate3_CT2")    // root for output filenames
    sprint(cmd,"mkdir -p %s",fileroot)
	system(cmd)
	
	whichcell = FindInd(tonefreq)  //get CF index close to 12.4kHz
	file.ropen("TStellate/CT2-01-305-014.png.dat")
	print "CT2 data CF ", tonefreq, "(Hz), location ", whichcell
	
	objref tempmat, ivdata[2]
	ivdata[0] = new Vector()
	ivdata[1] = new Vector()
	tempmat = new Matrix() //points, 2)
	tempmat.scanf(file)
	ivdata[0] = tempmat.getcol(0) //time
	ivdata[1] = tempmat.getcol(1) //voltage (mV)
	file.close()
	chopperIVgr =  new Graph()
	ivdata[1].plot(chopperIVgr,ivdata[0])
	chopperIVgr.exec_menu("View = plot")
	
	CalcIVMeasures_version2(ivdata[1],ivdata[0])
	

	IV_reference = new List()
	IV_weight = new List()
	//10 dB re thresh
	//IV_temp = new Vector(4,0)   
	//IV_reference.append(IV_temp) //No data
	//IV_weight.append(IV_temp)
	
	//20 dB re thresh
	IV_temp = new Vector(4,0)
	IV_temp.x[1] = MPadaptation_CT2.x[1][1]
	IV_temp.x[2] = MPhyper_CT2.x[1][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT2.x[1][2] //s.e.
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  //  
	IV_weight.append(IV_temp)
    
	//30 dB re thresh  (use actual trace in Figure 1)
	IV_temp = new Vector()
	CalcIVMeasures_version2(ivdata[1],ivdata[0])
	IV_temp.append(onset_ratio,adaptation_ratio ,offset_hyperpol,resting_value)    
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,1)
	IV_temp.x[3]=0  // ignore RMP
	IV_weight.append(IV_temp) //all data available
	
	
	
	//40 dB re thresh
	IV_temp = new Vector(4)   
	IV_reference.append(IV_temp)
	IV_temp.x[1] = MPadaptation_CT2.x[1][1]
	IV_temp.x[2] = MPhyper_CT2.x[2][1] //Hyperpolarisation
	IV_temp.x[3] = MPhyper_CT2.x[2][2] //s.e. of hyperpolarisation
	IV_reference.append(IV_temp)
	IV_temp = new Vector(4,0)
	IV_temp.x[1]=1  //  
	IV_temp.x[2]=1  // only offset hyperpol data used in error comparison   
	IV_weight.append(IV_temp)
	
	
	
	//CV
	SetupChopperCV()
	CV_reference = new List()
	CV_weight = new List()
	
	CV_temp = CV_transient2.getcol(1).c   
	CV_temp.remove(4)
	
	//10 dB re thresh
	//CV_temp = new Vector()   
	//CV_reference.append(CV_temp) //No data
    
	//20 dB re thresh  (remove the last elementin CVdata_CS)
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)
	
	
	//30 dB - Average data in Figure 2 
	CV_reference.append(CV_temp)   
	temp = new Vector(4,default_CV_weight*4)
	CV_weight.append(temp)
	
	
	//40 dB re thresh
	CV_reference.append(CV_temp)
	temp = new Vector(4,default_CV_weight)
	CV_weight.append(temp)
	
	sustained_transient_chopper=2
	
}


CT1_data()
//RefreshParameters()    //Generate or get stim from file
//ANFilterBankRun()

binwidth=0.5
objref iv,meaniv,psthgr,tstellate_spikes
psthgr = new Graph()

proc RunTStellate(){
	print "RunTStellate: "   
	RefreshCF()
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
	//CheckFilterbank()
	SetInputRates()
	
	
    objref iv,meaniv,tvec
	//ClearSpikes()
    iv = new Vector()
    iv.record(&tstellate[whichcell][0].soma.v(0.5))
    meaniv = new Vector(tstop/dt + 1,0)
    //tstellate[whichcell][0].spikes.resize(0)
	tstellate_spikes = new List()
    for ireps = 0, reps-1 {
        GenSpikes2()
        print ireps
        run()
        //SaveSpikes()
        tstellate_spikes.append(tstellate[whichcell][0].spiketimes.c)
        for i=0,tstop/dt-1{
			if (iv.x[i] > thresh) iv.x[i] = thresh
        }
        meaniv.add(iv)
        iv.mul(0)
    }
    meaniv.div(reps)
    tvec=new Vector(tstop/dt + 1)
    tvec.indgen(dt).add(-stimdelay*1000)
    meaniv.plot(chopperIVgr,tvec)
	
    chopperIVgr.exec_menu("View = plot")
	CalcIVMeasures_version2(ivdata[1],ivdata[0])
	CalcIVMeasures_version2(meaniv,ivdata[0])
	//psth = tstellate[whichcell][0].spikes.histogram(0,110,binwidth)
	//psth.plot(psthgr,binwidth) psthgr.exec_menu("View = plot")
	PSTHcell(tstellate_spikes,10,0)
	print "RunTStellate: done"  
}


param.ts_gnabar                  = 0.23677
param.ts_gkhtbar               = 0.0189416
param.ts_gleak                  = 0.000473539
param.ts_erev                  = -60.9
param.ts_ghbar                  = 6.20392e-05
param.ts_gkabar                  = 0.01539
param.ts_dend_g    = 0.001
param.ts_dend_e    = -65
param.ts_jitter_sd = 0.2
//param.ds_gleak/=10
//param.ds_gnabar/=2


proc reset_TStellate(){local ii
    print "updating features for T stellate optimisation routines"
    for ii = 0,nchannels-1 {
		//        if(ii == 20 || ii == 38 || ii == 51){
		sprint(cmd,"tstellate[%d][0].soma.gnabar_rm  = param.ts_gnabar",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.gkhtbar_rm = param.ts_gkhtbar",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.gleak_rm   = param.ts_gleak",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.erev_rm    = param.ts_erev",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.ghbar_rm   = param.ts_ghbar",ii) execute1(cmd)
		sprint(cmd,"tstellate[%d][0].soma.gkabar_ka  = param.ts_gkabar",ii) execute1(cmd)
		
		if (use_ball_stick == 1){
			sprint(cmd,"tstellate[%d][0].dend.g_pas  = param.ts_dend_g",ii) 
			execute1(cmd)
			sprint(cmd,"tstellate[%d][0].dend.e_pas  = param.ts_dend_e",ii) 
			execute1(cmd)
        }
		//        }
	}
}

// Calculate average IV measures  and put them in first three elements in input vector 3 
proc IVMeasures(){local offset
    /// args: 1 time vec, 2 voltage vec, 3 output vec (size=6), 4 offset
	if (numarg() != 4) {
		offset = stimdelay*1000
	} else {
		offset = $4
	}
	offset-=stimdelay*1000
	
	
    onset_depol = $o2.mean($o1.indwhere(">=",5.0), $o1.indwhere(">=",10.0))
    middle_depol = $o2.mean( $o1.indwhere(">=",20), $o1.indwhere(">=",30))
    onset_ratio = onset_depol / middle_depol
	
    v20_depol = $o2.mean( $o1.indwhere(">=",20) - 1, $o1.indwhere(">=",22))
    v50_depol = $o2.mean( $o1.indwhere(">=",50) - 1, $o1.indwhere(">=",52))
    adaptation_ratio = v20_depol - v50_depol
	
    resting_value  = $o2.mean($o1.indwhere(">",-10) , $o1.indwhere(">",0))
    v60_depol  = $o2.mean($o1.indwhere(">=",60) - 1, $o1.indwhere(">=",62))
    offset_hyperpol = resting_value - v60_depol
	
	//     onset_depol = $o2.mean($o1.indwhere(">=",5.0+offset), $o1.indwhere(">=",10.0+offset))
    // middle_depol = $o2.mean( $o1.indwhere(">=",20+offset), $o1.indwhere(">=",30+offset))
    // onset_ratio = onset_depol / middle_depol
	
    // v20_depol = $o2.mean( $o1.indwhere(">=",20+offset) - 1, $o1.indwhere(">=",22+offset))
    // v50_depol = $o2.mean( $o1.indwhere(">=",50+offset) - 1, $o1.indwhere(">=",52+offset))
    // adaptation_ratio = v20_depol - v50_depol
	
    // resting_value  = $o2.mean($o1.indwhere(">",-10) , $o1.indwhere(">",0))
    // v60_depol  = $o2.mean($o1.indwhere(">=",60+offset) - 1, $o1.indwhere(">=",65+offset))
    // offset_hyperpol = resting_value - v60_depol
	
	
    $o3.x[0] = onset_ratio
    $o3.x[1] = adaptation_ratio
    $o3.x[2] = offset_hyperpol
	print "resting membrane potential              ", resting_value
	print "level of initial depolarization         ", onset_ratio
	print "adaptation of sustained depolarization  ", adaptation_ratio
	print "post-tone hyperpolarization             ", offset_hyperpol
	
}



//mimick connect_CNcells from CochlearNucleus.hoc
proc connect_TS() {local i_chan,i,p,target,source,low,high,range,channel,sourcechannel
	
	objref tstellate[nchannels][nTSperchannel]
	
	for i_chan = 0, nchannels-1 {
		if (nTSperchannel > 0) {
			for j_cell = 0, nTSperchannel-1 {
				if(use_ball_stick==0){
					sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d)",i_chan,j_cell,i_chan,i_chan)
				} else {
					sprint(cmd, "tstellate[%d][%d] = new CNcell(0,cf.x[%d],%d,1)",i_chan,j_cell,i_chan,i_chan)
				}
				execute1(cmd)
			}
		}   
	}   
	
	
	
	print "Connecting cells."
	sprint(filename,"%s.connect",$s1)
	outfile.wopen(filename)
	
	
	objref    hsr2tsAMPAlist,   lsr2tsAMPAlist,   glg2tsGABAlist,   ds2tsGLYlist,   tv2tsGLYlist,   ts2tsAMPAlist
	
	hsr2tsAMPAlist = new List()
	lsr2tsAMPAlist = new List()
	glg2tsGABAlist = new List()
	ds2tsGLYlist  = new List() 
	tv2tsGLYlist  = new List() 
	ts2tsAMPAlist  = new List()
	
	
	
	if( ( param.n.getval(hsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",hsr,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(hsr,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(hsr,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1 + int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells in sourcechannel
					source = random.discunif(0,HSRsperchannel-1)
					//print "HSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
					sprint(cmd, "tstellate[%d][%d].soma hsr2tsAMPAlist.append( new NetCon( an.HSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(hsr,ts), param.w.getval(hsr,ts)))",channel,target,sourcechannel,source,channel,target)
					execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rHSR->TS === %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rHSR->TS === done ===\n")
	}
	
	if( ( param.n.getval(lsr,ts) > 0 ) && ( nTSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",lsr,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(lsr,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(lsr,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells
					source = random.discunif(0,LSRsperchannel-1)
					//print "LSR[",sourcechannel,"][",source,"] connected to TS[",channel,"][",target,"]"
					sprint(cmd, "tstellate[%d][%d].soma lsr2tsAMPAlist.append( new NetCon( an.LSR[%d][%d], tstellate[%d][%d].AMPA, thresh,param.delay.getval(lsr,ts), param.w.getval(lsr,ts)))",channel,target,sourcechannel,source,channel,target)
					execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rLSR->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rLSR->TS=== done ===\n")
	}
	
	
	print "Connecting CN network cells to TS cells"
	
	
	if( ( param.n.getval(ts,ts) > 0 ) && ( nTSperchannel > 1 ) ){
		outfile.printf("%d %d\n",ts,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(ts,ts)-1{
					//Choose random source from available cells
					source = random.discunif(0,nTSperchannel-1)
					while( source == target)  source = random.repick()  //Don't connect to self
					// print "TS[",channel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					// tscells[channel*numTSperchannel+target].connect_pre(tscells[source], 1, param.delay.getval(ts,ts), param.w.getval(ts,ts))
					sprint(cmd, "tstellate[%d][%d].soma ts2tsAMPAlist.append( new NetCon(&v(0.5), tstellate[%d][%d].AMPA, thresh,param.delay.getval(ts,ts), param.w.getval(ts,ts)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					outfile.printf("%d %d %d %d\n",channel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rTS->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rTS->TS=== done ===\n")
	}
	
	
	if( ( param.n.getval(tv,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nTVperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",tv,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(tv,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(tv,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells
					source = random.discunif(0,nTVperchannel-1)
					// print "TV[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					sprint(cmd, "tuberculoventral[%d][%d].soma tv2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR,  thresh,param.delay.getval(tv,ts), param.w.getval(tv,ts)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
					
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rTV->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rTV->TS=== done ===\n")
	}
	
	if( ( param.n.getval(ds,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",ds,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(ds,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(ds,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					//Choose random source from available cells
					source = random.discunif(0,nDSperchannel-1)
					// print "DS[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					sprint(cmd, "dstellate[%d][%d].soma ds2tsGLYlist.append( new NetCon(&v(0.5), tstellate[%d][%d].GlyR, thresh,param.delay.getval(ds,ts), param.w.getval(ds,ts)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rDS->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rDS->TS=== done ===\n")
	}
	
	
	if( ( param.n.getval(glg,ts) > 0 ) && ( nTSperchannel != 0 ) && ( nGperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",glg,ts)
		for channel = 0, nchannels-1{
			for target = 0, nTSperchannel-1 {
				for i=0, param.n.getval(glg,ts)-1{
					//Choose source channel
					sourcechannel = random.normal(channel,param.bw.getval(glg,ts)/2)
					if ((sourcechannel - int(sourcechannel)) > 0.5 ){
						sourcechannel = 1+int(sourcechannel)
					} else { 
						sourcechannel = int(sourcechannel) 
					}
					if (sourcechannel <=0 ) sourcechannel=0
					if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
					
					//Choose random source from available cells
					source = random.discunif(0,nGperchannel-1)
					// print "GLG[",sourcechannel,"][",source,"] connected to "TS[",channel,"][",target,"]"
					if (LSR2GLG ==1 ) { //Conductance model of golgi
						sprint(cmd, "golgi[%d][%d].soma glg2tsGABAlist.append( new NetCon(&v(0.5),tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
						execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
					} else { //filter based model of golgi
						sprint(cmd, "glg2tsGABAlist.append( new NetCon( golgi[%d][%d].sg, tstellate[%d][%d].GABAA, thresh,param.delay.getval(glg,ts), param.w.getval(glg,ts)))",sourcechannel,source,channel,target)
						execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
					}
					outfile.printf("%d %d %d %d\n",sourcechannel,source,channel,target)
				}
			}
			p = 100*(channel)/(nchannels)
			printf("\rGLG->TS=== %3d%% ===",p)
			flushf()
			doNotify() // Although this slows down cell creation, the
			// process is so long that we have to allow the
			// user to quit during the creation.
		}
		printf("\rGLG->TS=== done ===\n")
	}
	outfile.close()   
}

threshold_rate = 0
threshold_penalty = 0
