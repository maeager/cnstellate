/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/*
*   TV_Notch.hoc
*
*/
load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")

xopen("mathslib.hoc")         // mathematical procedures
xopen("Params.hoc")           // default parameters
xopen("Utilities.hoc")
xopen("NetworkParameters.hoc")
xopen("AuditoryNerve.hoc")
xopen("par_CNcell.tem")      // CN cell template
xopen("parameters_TV_RateLevel.hoc")     //This model's parameters
xopen("CochlearNucleus.hoc")         // model set-up
//--- Setup Auditory and CN Stellate model
create_cells()
connect_cells(fileroot)
connect_CNcells(fileroot)
//Previous optimisation parameters
xopen("pvec_Golgi_RateLevel.hoc")
xopen("pvec_DS_ClickRecovery.hoc")

reset_weights()
reset_DS_ClickRecovery()

//Setup this experiment
xopen("par_experiment_TV_RateLevel.hoc")

xopen("cngui.hoc")


objref tuberculoventral[1][2]
sprint(cmd, "tuberculoventral[%d][%d] = new CNcell(1,cf.x[%d],%d)",0,0,50,50)
execute1(cmd)
sprint(cmd, "tuberculoventral[%d][%d] = new CNcell(1,cf.x[%d],%d)",0,1,50,50)
execute1(cmd)

proc connect_TV() {local i,p,target,source,low,high,range,channel,sourcechannel
	
	
	print "Connecting cells."
	sprint(filename,"%s.connect",$s1)
	outfile.wopen(filename)
	
	hsr2tvAMPAlist.remove_all()
	lsr2tvAMPAlist.remove_all()
	glg2tvGABAlist.remove_all()
	ds2tvGLYlist.remove_all()
	ts2tvAMPAlist.remove_all()
	
	
	if( param.n.getval(hsr,tv) > 0  ){
		outfile.printf("\n%d %d\n",hsr,tv)
		channel = 0
		for target = 0, 1 {
			for i=0, param.n.getval(hsr,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[channel][target].channel,param.bw.getval(hsr,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else { sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				//Choose random source from available cells
				source = random.discunif(0,HSRsperchannel-1)
				//print "HSR[",sourcechannel,"][",source,"] connected to TV[",channel,"][",target,"]"
				sprint(cmd, " tuberculoventral[%d][%d].soma hsr2tvAMPAlist.append( new NetCon( an.HSR[%d][%d],tuberculoventral[%d][%d].AMPA,thresh,param.delay.getval(hsr,tv), param.w.getval(hsr,tv)))",0,target,sourcechannel,source,0,target)
				execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
				outfile.printf("%d %d %d %d\n",sourcechannel,source,50,target)
				
			}
		}
		printf("HSR->TV=== done ===\n")
	}
	
	if( param.n.getval(lsr,tv) > 0  ){
		outfile.printf("\n%d %d\n",lsr,tv)
		channel = 0
		for target = 0, 1 {
			for i=0, param.n.getval(lsr,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[channel][target].channel,param.bw.getval(lsr,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else 	{ sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				//Choose random source from available cells
				source = random.discunif(0,LSRsperchannel-1)
				sprint(cmd, "tuberculoventral[%d][%d].soma lsr2tvAMPAlist.append( new NetCon( an.LSR[%d][%d],   tuberculoventral[%d][%d].AMPA,thresh,param.delay.getval(lsr,tv), param.w.getval(lsr,tv)))",0,target,sourcechannel,source,0,target)
				execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
				outfile.printf("%d %d %d %d\n",sourcechannel,source,50,target)
				
			}
		}
		printf("LSR->TV=== done ===\n")
	}
	
	print "Connecting CN network cells"
	
	if( ( param.n.getval(ds,tv) > 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",ds,tv)
		channel = 0
		for target = 0,1 {
			for i=0, param.n.getval(ds,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[channel][target].channel,param.bw.getval(ds,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else { sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				//Choose random source from available cells
				source = random.discunif(0,nDSperchannel-1)
				// print "DS[",sourcechannel,"][",source,"] connected to "TV[",channel,"][",target,"]"
				sprint(cmd, "dstellate[%d][%d].soma ds2tvGLYlist.append( new NetCon(&v(0.5), tuberculoventral[%d][%d].GlyR, thresh,param.delay.getval(ds,tv), param.w.getval(ds,tv)))",sourcechannel,source,0,target)
				execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
				outfile.printf("%d %d %d %d\n",sourcechannel,source,0,target)
			}
		}
		printf("DS->TV=== done ===\n")
	}
	
	if( ( param.n.getval(glg,tv) > 0 ) &&  ( nGperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",glg,tv)
		channel = 0
		for target = 0, 1 {
			for i=0, param.n.getval(glg,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[0][target].channel,param.bw.getval(glg,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else { sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				
				//Choose random source from available cells
				source = random.discunif(0,nGperchannel-1)
				// print "GLG[",sourcechannel,"][",source,"] connected to "TV[",channel,"][",target,"]"
				if (LSR2GLG ==1 ) { //Conductance model of golgi
					sprint(cmd, "golgi[%d][%d].soma glg2tvGABAlist.append( new NetCon(&v(0.5),tuberculoventral[%d][%d].GABAA, thresh,param.delay.getval(glg,tv), param.w.getval(glg,tv)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
				} \
				else { //filter based model of golgi
					sprint(cmd, "glg2tvGABAlist.append( new NetCon( golgi[%d][%d].sg, tuberculoventral[%d][%d].GABAA, thresh,param.delay.getval(glg,tv), param.w.getval(glg,tv)))",sourcechannel,source,0,target)
					execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
				}
				outfile.printf("%d %d %d %d\n",sourcechannel,source,0,target)
			}
		}
		printf("GLG->TV=== done ===\n")
	}
	outfile.close()
}

connect_TV(fileroot)


proc SaveSpikes(){local i,j //overload CochlearNucleus
	an.SaveSpikes()
	i=0	
	for j=0,1{
        sprint(cmd, "tuberculoventral[%d][%d].spikes.append(tuberculoventral[%d][%d].spiketimes)",i,j,i,j)
	    execute1(cmd)
	}
}



proc multi_run(){local irep,xtime
    xtime = startsw()
    ClearSpikes()
    for irep=0,reps-1{
		GenInputSpikes()
		print irep
		//run()
		stdinit()
		continuerun(tstop)
        SaveSpikes()
    }
    print "Multi_run time:", startsw() - xtime
}


// Sound level in dB attenuation refers to noise spectrum level at 0 dB equal to \~40 dB re 20 $\mu$Pa/Hz$^{1/2}$.


//////////Default Parameters for TV_RateLevel///////////////

ANsoundspath			= "../../sounds"
cfhi				= 48000
cflo				= 200
RefreshCF()
ramplngth			= 0.002
stimdelay			= 0.02   //sec, 20 msec
dutycycle = 0 //don't have quiet at the end, usually 0.2
reps				= 25     //
ANmodel				= 7      // Zilany Bruce model version 3
species				= 1      // Cat
ANFBgr					= new Graph()
usesavedfilterbanks		= 1
srate					= 100000
stimtdres				= 1/srate
sg_rate					= 50000
sg_tdres				= 1/sg_rate
RefreshCF()
GetAudiogramData()
RefreshParameters()
//  ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()


proc TV_2tone(){
	stimtype			= 9     //TwoTone
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = 6600 //Hz, unit 1 CF
	tone2freq           = 9350 //Hz ,unit 2 
	tone2spl            = spl // set the second tone's sound level to the same as the first
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

proc TV_BFtone(){
	stimtype			= 1     //TwoTone
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = cf.x[50] //Hz, unit 1 CF
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

proc TV_Noise(){
	stimtype			= 6     //BBN 
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = cf.x[50] //Hz, unit 1 CF
	GetAudiogramData()
	RefreshParameters()
//	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}




//xopen("TV_Notch.ses")

objref fitgr,gg
//TV Optimisation
objref gr,target_ratelevel, dslist, fvec,dvec,ivec,weighting,errorvec
objref anrate[nchannels],rate_level_graph
gr = new Graph()


//
// Fitness/error function
//
proc plot_fitgr(){
    objref fitgr
    fitgr = new Graph()
//    expected_notch[1].plot(fitgr,freq1_notch,4,1)
//    CNrate[tv].plot(fitgr,cf,3,1)
//    type2_1oct_sweep[1].plot(fitgr,freq_1oct,5,1)
//    fitgr.exec_menu("View = plot")
}

objref templevel,indlevel,errorvec,refvec



reps=20
strdef origfileroot
origfileroot = fileroot

error=0
strdef datestr,grlbl
objref ivec,pval[NPARAMS]
ivec= new Vector()
ivec.append(3,9,7,5,1,2,8,6,4,0,10,11,12,13)





//QuickRun()
//spl=50
//sprint(fileroot,"%s_spl50",origfileroot)
//param.w.x[hsr][tv]=-0.0002
//param.w.x[lsr][tv]*=2
objref origpvec
set_pvec()
origpvec = pvec.c


proc RedefineTVmodel(){local i_chan,j_cell,ii
	//define the cell objects
	
    objref tuberculoventral[nchannels][2]
	objref hsr2tvAMPAlist, lsr2tvAMPAlist, ds2tvGLYlist
	
	hsr2tvAMPAlist = new List()
	lsr2tvAMPAlist = new List()
	hsr2dsAMPAlist = new List()
	lsr2dsAMPAlist = new List()
	glg2dsGABAlist = new List()
	ds2tvGLYlist = new List()
	connect_TV(origfileroot)
	for ii=0,1 tuberculoventral[0][ii].soma.erev_rm = param.tv_erev
}



objref ind,isi
isistdev =0
func meanrate(){ local i localobj spikes
// Take in a spike vector ( presume an appended vector of 50 spike trains)
	// remove values less than the stimulus delay
	// calculate intervals, remove negative intervals,
	// mean rate is the inverse of the isi mean
	objref ind,isi
	spikes = new Vector()
	if ($o1.size < 60) {
		isistdev = 10
		return $o1.size()/(reps*0.05)
	}
	spikes.copy($o1)
	ind = new Vector()
	isi = new Vector()
	ind.indvwhere(spikes,"<",stimdelay*1000)
	if (spikes.size -ind.size <= 5) {
		isistdev = 10
		return spikes.size()/(reps*0.05)
	}
	if (ind.size > 0) for i=0, ind.size-1 { spikes.remove(ind.x[i]-i) }
	print "print spikes.size", spikes.size
	for i=1,spikes.size-1 {
		isi.append( spikes.x[i]-spikes.x[i-1])
	}
	print "print isi.size", isi.size
	
	ind.indvwhere(isi,"<=",0)
	if (isi.size -ind.size <= 10) {
		isistdev = 10
		return spikes.size()/(reps*0.05)
	}
	if (ind.size > 0) for i=0, ind.size-1 { isi.remove(ind.x[i]-i)
	print "removing ", ind.x[i] }
	ind.indvwhere(isi,">",50)
	if (ind.size >= 1) {
		if (isi.size -ind.size <= 3) {
			isistdev = 15
			return spikes.size()/(reps*0.05)
		}
		for i=0, ind.size-1 { isi.remove(ind.x[i]-i)
		print "removing ", ind.x[i] }
	}
	print "print isi.size", isi.size
	
	if (isi.size <= 1) {
		isistdev = 1e6
		return spikes.size()/(reps*0.05)
	}
	
	isistdev = isi.stdev()
	return 1000/isi.mean()
}


objref tvpstlist, tvrate[nchannels],anrate[nchannels],rate_level_graph, tvstdev[nchannels],level,fvec
proc Ratelevel(){local ispl,i,j,count,sum,runtime,cell,xtime localobj tmp	
	count = 0
	reps=25
	tvpstlist = new List()
	for i=0,99 {
		tvrate[i] = new Vector()
		anrate[i] = new Vector()
		tvstdev[i] = new Vector()
	}
	fvec = new Vector()
	//RefreshParameters()
	//ANFilterBankRun()
	for ispl=0,level.size-1 {
		spl = level.x[ispl]
		runtime = startsw()
		ClearSpikes()
		RefreshParameters()
		ANFilterBankRun()
		SetInputRates()
		
		multi_run()
		
		 for j=0,1 {
		// 	sum=0
		 	tvrate[j].append(meanrate(tuberculoventral[0][j].spikes))
		 	tvstdev[j].append(isistdev)
		}
		for i=0,LSRsperchannel-1 
			sum+= meanrate(an.LSRspiketimes[50][i])
		anrate[0].append(sum/(LSRsperchannel))
		for i=0,HSRsperchannel-1 
 		   sum+=meanrate(an.HSRspiketimes[50][i])
		anrate[1].append(sum/(HSRsperchannel))
		
//		fvec.append(golgi[76][0].sout.mean(2000,3000))
		
		
		count+=1
		runtime = startsw()-runtime
		print "Simulation took ",runtime, " secs "
	}
	
	rate_level_graph = new Graph()
//	fvec.plot(rate_level_graph,2,2)
	tvrate[0].plot(rate_level_graph)
	tvrate[1].plot(rate_level_graph)
	anrate[0].plot(rate_level_graph)
	anrate[1].plot(rate_level_graph)
	rate_level_graph.exec_menu("View = plot")
	
}//Ratelevel

/*

TV_BFtone()
level=new Vector(20)
level.indgen().mul(3).add(20) //20:3:60
Ratelevel()
TV_Noise()
level=new Vector(20)
level.indgen().mul(2).add(50)
Ratelevel()

*/
