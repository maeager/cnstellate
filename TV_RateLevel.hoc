/* -*- mode: nrnhoc; tab-width: 4; indent-tabs-mode: t -*- */

/*
 *   TV_Notch.hoc
 *   
 *    Copyright Â© 2012 Michael Eager, (mick.eager@gmail.com)
 *    cnstellate was written as part of my PhD at The University of Melbourne
 *
 *    This file is part of cnstellate.
 * 
 *    This is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.  
 */


load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")

xopen("mathslib.hoc")         // mathematical procedures
xopen("Params.hoc")           // default parameters
xopen("Utilities.hoc")
xopen("NetworkParameters.hoc")
xopen("AuditoryNerve.hoc")
xopen("par_CNcell.tem")      // CN cell template
xopen("parameters_TV_RateLevel.hoc")     //This model's parameters
xopen("CochlearNucleus.hoc")         // model set-up
//--- Setup Auditory and CN Stellate model
create_cells()
connect_cells(fileroot)
connect_CNcells(fileroot)
//Previous optimisation parameters
xopen("pvec_Golgi_RateLevel.hoc")
xopen("pvec_DS_ClickRecovery.hoc")

reset_weights()
reset_DS_ClickRecovery()

//Setup this experiment
xopen("par_experiment_TV_RateLevel.hoc")
xopen("cngui.hoc")

//Require 2 TV units with CF = f(position 50)
objref tuberculoventral[1][2]

//mimick connect_CNcells from CochlearNucleus.hoc
proc create_connect_TV() {local i,p,target,source,low,high,range,channel,sourcechannel

  //Require 2 TV units with CF = f(position 50)
  objref tuberculoventral[1][2]
  sprint(cmd, "tuberculoventral[%d][%d] = new CNcell(1,cf.x[%d],%d)",0,0,50,50)
  execute1(cmd)
  sprint(cmd, "tuberculoventral[%d][%d] = new CNcell(1,cf.x[%d],%d)",0,1,50,50)
  execute1(cmd)


	print "Connecting cells."
	sprint(filename,"%s.connect",$s1)
	outfile.wopen(filename)
	
	hsr2tvAMPAlist.remove_all()
	lsr2tvAMPAlist.remove_all()
	glg2tvGABAlist.remove_all()
	ds2tvGLYlist.remove_all()
	ts2tvAMPAlist.remove_all()
	
	
	if( param.n.getval(hsr,tv) > 0  ){
		outfile.printf("\n%d %d\n",hsr,tv)
		channel = 0
		for target = 0, 1 {
			for i=0, param.n.getval(hsr,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[channel][target].channel,param.bw.getval(hsr,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else { sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				//Choose random source from available cells
				source = random.discunif(0,HSRsperchannel-1)
				//print "HSR[",sourcechannel,"][",source,"] connected to TV[",channel,"][",target,"]"
				sprint(cmd, " tuberculoventral[%d][%d].soma hsr2tvAMPAlist.append( new NetCon( an.HSR[%d][%d],tuberculoventral[%d][%d].AMPA,thresh,param.delay.getval(hsr,tv), param.w.getval(hsr,tv)))",0,target,sourcechannel,source,0,target)
				execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
				outfile.printf("%d %d %d %d\n",sourcechannel,source,50,target)
				
			}
		}
		printf("HSR->TV=== done ===\n")
	}
	
	if( param.n.getval(lsr,tv) > 0  ){
		outfile.printf("\n%d %d\n",lsr,tv)
		channel = 0
		for target = 0, 1 {
			for i=0, param.n.getval(lsr,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[channel][target].channel,param.bw.getval(lsr,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else 	{ sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				//Choose random source from available cells
				source = random.discunif(0,LSRsperchannel-1)
				sprint(cmd, "tuberculoventral[%d][%d].soma lsr2tvAMPAlist.append( new NetCon( an.LSR[%d][%d],   tuberculoventral[%d][%d].AMPA,thresh,param.delay.getval(lsr,tv), param.w.getval(lsr,tv)))",0,target,sourcechannel,source,0,target)
				execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
				outfile.printf("%d %d %d %d\n",sourcechannel,source,50,target)
				
			}
		}
		printf("LSR->TV=== done ===\n")
	}
	
	print "Connecting CN network cells"
	
	if( ( param.n.getval(ds,tv) > 0 ) && ( nDSperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",ds,tv)
		channel = 0
		for target = 0,1 {
			for i=0, param.n.getval(ds,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[channel][target].channel,param.bw.getval(ds,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else { sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				//Choose random source from available cells
				source = random.discunif(0,nDSperchannel-1)
				// print "DS[",sourcechannel,"][",source,"] connected to "TV[",channel,"][",target,"]"
				sprint(cmd, "dstellate[%d][%d].soma ds2tvGLYlist.append( new NetCon(&v(0.5), tuberculoventral[%d][%d].GlyR, thresh,param.delay.getval(ds,tv), param.w.getval(ds,tv)))",sourcechannel,source,0,target)
				execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
				outfile.printf("%d %d %d %d\n",sourcechannel,source,0,target)
			}
		}
		printf("DS->TV=== done ===\n")
	}
	
	if( ( param.n.getval(glg,tv) > 0 ) &&  ( nGperchannel != 0 ) ){
		outfile.printf("\n%d %d\n",glg,tv)
		channel = 0
		for target = 0, 1 {
			for i=0, param.n.getval(glg,tv)-1{
				//Choose source channel
				sourcechannel = random.normal(tuberculoventral[0][target].channel,param.bw.getval(glg,tv)/2)
				if ((sourcechannel - int(sourcechannel)) > 0.5 ){
					sourcechannel = 1+int(sourcechannel)
				} \
				else { sourcechannel = int(sourcechannel) }
				if (sourcechannel <=0 ) sourcechannel=0
				if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
				
				//Choose random source from available cells
				source = random.discunif(0,nGperchannel-1)
				// print "GLG[",sourcechannel,"][",source,"] connected to "TV[",channel,"][",target,"]"
				if (LSR2GLG ==1 ) { //Conductance model of golgi
					sprint(cmd, "golgi[%d][%d].soma glg2tvGABAlist.append( new NetCon(&v(0.5),tuberculoventral[%d][%d].GABAA, thresh,param.delay.getval(glg,tv), param.w.getval(glg,tv)))",sourcechannel,source,channel,target)
					execute1(cmd) //syn id=0 AMPA, =1 GLY =2 GABAa
				} \
				else { //filter based model of golgi
					sprint(cmd, "glg2tvGABAlist.append( new NetCon( golgi[%d][%d].sg, tuberculoventral[%d][%d].GABAA, thresh,param.delay.getval(glg,tv), param.w.getval(glg,tv)))",sourcechannel,source,0,target)
					execute1(cmd) //syn id: 0=AMPA, 1= GLY 2= GABAa
				}
				outfile.printf("%d %d %d %d\n",sourcechannel,source,0,target)
			}
		}
		printf("GLG->TV=== done ===\n")
	}
	outfile.close()
	
	tuberculoventral[0][0].soma.erev_rm = param.tv_erev
	tuberculoventral[0][1].soma.erev_rm = param.tv_erev
}

param.tv_erev=-65
param.offset=0
param.n.x[ds][tv] = 20
param.bw.x[ds][tv] = 15

create_connect_TV(fileroot)

//overload SaveSpikes from CochlearNucleus.hoc
proc SaveSpikes(){local i,j 
	an.SaveSpikes()
	i=0	
	for j=0,1{
		sprint(cmd, "tuberculoventral[%d][%d].SaveSpikes()",i,j)
		execute1(cmd)
	}
	for i=0,nchannels-1 {
        sprint(cmd, "dstellate[%d][0].SaveSpikes()",i)
	    execute1(cmd)
	}
	for i=0,nchannels-1 {
        sprint(cmd, "golgi[%d][0].SaveSpikes()",i)
	    execute1(cmd)
	}
	
}

//overload ClearSpikes from CochlearNucleus.hoc
proc ClearSpikes(){local ii,jj
    ClearInputSpikes()
       for jj=0,1{
			sprint(cmd, "tuberculoventral[0][%d].spikes.resize(0)",jj)
            execute1(cmd)
        }
 	
	for ii=0,nchannels-1{
        for jj=0,nDSperchannel-1{
			sprint(cmd, "dstellate[%d][%d].spikes.resize(0)",ii,jj)
            execute1(cmd)
        }
        for jj=0,nGperchannel-1{
			sprint(cmd, "golgi[%d][%d].spikes.resize(0)",ii,jj)
            execute1(cmd)
        }
    }
 print "Cleared CN cell Spikes"
}


proc multi_run(){local irep,xtime
    xtime = startsw()
    ClearSpikes()
    for irep=0,reps-1{
		GenInputSpikes()
		print irep
		//run()
		stdinit()
		continuerun(tstop)
        SaveSpikes()
    }
    print "Multi_run time:", startsw() - xtime
}


// Sound level in dB attenuation refers to noise spectrum level at 0 dB equal to \~40 dB re 20 $\mu$Pa/Hz$^{1/2}$.


//////////Default Parameters for TV_RateLevel///////////////

ANsoundspath			= "../../sounds"
cfhi				= 48000
cflo				= 200
RefreshCF()
ramplngth			= 0.002
stimdelay			= 0.02   //sec, 20 msec
dutycycle           = 0.2 //don't have quiet at the end, usually 0.2
reps				= 25     //
ANmodel				= 6      // Zilany Bruce model version 3
species				= 1      // Cat
ANFBgr					= new Graph()
usesavedfilterbanks		= 1
srate					= 500000
stimtdres				= 1/srate
sg_rate					= 50000
sg_tdres				= 1/sg_rate
RefreshCF()
GetAudiogramData()
RefreshParameters()
//  ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()


proc TV_2tone(){
	stimtype			= 9     //TwoTone
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = 6600 //Hz, unit 1 CF
	tone2freq           = 9350 //Hz ,unit 2 
	tone2spl            = spl // set the second tone's sound level to the same as the first
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

proc TV_BFtone(){
	stimtype			= 1     // Pure Tone
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = cf.x[50] //Hz, unit 1 CF
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}

proc TV_Noise(){
	stimtype			= 6     //BBN 
	dur				    = 0.049  // duration of stim (seconds)
	tstop				= 70    // ms
	spl				    = 20     //dB SPL
	tonefreq            = cf.x[50] //Hz, unit 1 CF
	GetAudiogramData()
	RefreshParameters()
	ANFilterBankRun()
//  CheckFilterbank()
//  SetInputRates()
}




//xopen("TV_Notch.ses")

objref fitgr,gg
//TV Optimisation
objref gr,target_ratelevel, dslist, fvec,dvec,ivec,weighting,errorvec
objref anrate[nchannels],rate_level_graph
gr = new Graph()


//
// Fitness/error function
//
proc plot_fitgr(){
    objref fitgr
    fitgr = new Graph()
//    expected_notch[1].plot(fitgr,freq1_notch,4,1)
//    CNrate[tv].plot(fitgr,cf,3,1)
//    type2_1oct_sweep[1].plot(fitgr,freq_1oct,5,1)
//    fitgr.exec_menu("View = plot")
}

objref templevel,indlevel,errorvec,refvec

reps=20
strdef origfileroot
origfileroot = fileroot

error=0
strdef datestr,grlbl
objref ivec //,pval[NPARAMS]
ivec= new Vector()
ivec.append(3,9,7,5,1,2,8,6,4,0,10,11,12,13)





proc RedefineTVmodel(){local i_chan,j_cell,ii
	//define the cell objects
	
    objref tuberculoventral[nchannels][2]
	objref hsr2tvAMPAlist, lsr2tvAMPAlist, ds2tvGLYlist
	
	hsr2tvAMPAlist = new List()
	lsr2tvAMPAlist = new List()
	hsr2dsAMPAlist = new List()
	lsr2dsAMPAlist = new List()
	glg2dsGABAlist = new List()
	ds2tvGLYlist = new List()
	connect_TV(origfileroot)
	for ii=0,1 tuberculoventral[0][ii].soma.erev_rm = param.tv_erev
}



objref ind,isi
isistdev =0
func meanrate(){ local i localobj spikes
    // Take in a spike vector ( presume an appended vector of 50 spike trains)
	// remove values less than the stimulus delay
	// calculate intervals, remove negative intervals,
	// mean rate is the inverse of the isi mean
	objref ind,isi
	spikes = new Vector()
	if ($o1.size < reps*2 ) {
		isistdev = 10
		if ($o1.size() <= 0) return 0
		return $o1.size()/(reps*(dur+ramplngth/2))
	}
	spikes.copy($o1)
	ind = new Vector()
	isi = new Vector()
	ind.indvwhere(spikes,"<",stimdelay*1000)
	if (spikes.size - ind.size <= 5) {
		isistdev = 10
		return spikes.size()/(reps*(dur+ramplngth/2))
	}
	if (ind.size > 0) for i=0, ind.size-1 { spikes.remove(ind.x[i]-i) }
	print "print spikes.size", spikes.size
	for i=1,spikes.size-1 {
		isi.append( spikes.x[i]-spikes.x[i-1])
	}
	print "print isi.size", isi.size
	
	ind.indvwhere(isi,"<=",0)
	if (isi.size -ind.size <= 10) {
		isistdev = 10
		return spikes.size()/(reps*(dur+ramplngth/2))
	}
	if (ind.size > 0) for i=0, ind.size-1 { 
		isi.remove(ind.x[i]-i)
//		print "removing ", ind.x[i] 
	}
	ind.indvwhere(isi,">", (dur+ramplngth/2)*1000)
	if (ind.size >= 1) {
		if (isi.size - ind.size <= 3) {
			isistdev = 15
			return spikes.size()/(reps*(dur+ramplngth/2))
		}
		for i=0, ind.size-1 { 
			isi.remove(ind.x[i]-i)
//			print "removing ", ind.x[i] 
		}
	}
	print "print isi.size", isi.size
	 
	if (isi.size < 3) {
		isistdev = 1e6
		return spikes.size()/(reps*(dur+ramplngth/2))
	}
	
	isistdev = isi.stdev()
	return 1000/isi.mean()
}

level_offset=25

objref tvpstlist, grate[nchannels],dsrate[nchannels],tvrate[nchannels],hsrrate[nchannels],lsrrate[nchannels],rate_level_graph, tvstdev[nchannels],level,fvec
proc Ratelevel(){local ispl,i,j,count,sum,runtime,cell,xtime localobj tmp	
	count = 0
	tvpstlist = new List()
	for i=0,99 {
		tvrate[i] = new Vector()
		dsrate[i] = new Vector()
		lsrrate[i] = new Vector()
		hsrrate[i] = new Vector()
		tvstdev[i] = new Vector()
		grate[i] = new Vector()
	}
	fvec = new Vector()
	//RefreshParameters()
	//ANFilterBankRun()
	for ispl=0,level.size-1 {
		spl = level.x[ispl] - level_offset
		runtime = startsw()
		ClearSpikes()
        for j=0,1 tuberculoventral[0][j].spikes = new Vector()
		RefreshParameters()
		ANFilterBankRun()
		SetInputRates()
		multi_run()
		
for j=0,1 {
	//	sum=0
	meanrate(tuberculoventral[0][j].spikes)
	tvrate[j].append(tuberculoventral[0][j].spikes.size / (reps *0.05))
	tvstdev[j].append(isistdev)
}

ANSpikes()
for j=0,nchannels-1 {
	meanrate(dstellate[j][0].spikes)
	meanrate(golgi[j][0].spikes)
	grate[j].append(golgi[j][0].spikes.size / (reps * 0.05))
	dsrate[j].append(dstellate[j][0].spikes.size / (reps * 0.05))
	for i=1,HSRsperchannel-1 an.HSRspikes[j][0].append(an.HSRspikes[j][i])
	for i=1,LSRsperchannel-1 an.LSRspikes[j][0].append(an.LSRspikes[j][i])
	meanrate(an.HSRspikes[j][0])
	meanrate(an.LSRspikes[j][0])

	hsrrate[j].append(an.HSRspikes[j][0].size / (HSRsperchannel * reps * 0.05))
	lsrrate[j].append(an.LSRspikes[j][0].size / (LSRsperchannel * reps * 0.05))
}

		
		count+=1
		runtime = startsw()-runtime
		print "Simulation took ",runtime, " secs "
	}
	
	rate_level_graph = new Graph()
//	fvec.plot(rate_level_graph,2,2)
	tvrate[0].plot(rate_level_graph,level ,1,1)
	tvrate[1].plot(rate_level_graph,level ,2,1)
	grate[50].plot(rate_level_graph,level,5,1)	
	dsrate[50].plot(rate_level_graph,level,3,1)	
	hsrrate[50].plot(rate_level_graph,level,4,1)
	lsrrate[50].plot(rate_level_graph,level,5,1)
	rate_level_graph.exec_menu("View = plot")
	
}//Ratelevel

proc save_rate_level(){
	sprint(fname,"%s/rate_level.dat",fileroot)
	file.aopen(fname)
	for i=0,level.size-1{
		file.printf("%d\t%g\t%g\t%g\t%g\t%g\t%g\n",level.x[i],\
		tvrate[0].x[i],tvrate[1].x[i],\
		dsrate[50].x[i],grate[50].x[i], \
		hsrrate[50].x[i],lsrrate[50].x[i])
			
	}
	file.close()
}	

/*
TV_BFtone()
level=new Vector(20)
level.indgen().mul(3).add(20) //20:3:60
Ratelevel()
TV_Noise()
level=new Vector(20)
level.indgen().mul(2).add(50)
Ratelevel()
*/


for i = 0, nchannels-1 {
	dstellate[i][0].soma.gnabar_rm=0.408307 
	dstellate[i][0].soma.gkhtbar_rm=0.030623 
	dstellate[i][0].soma.gleak_rm=0.000274146 
	dstellate[i][0].soma.erev_rm=-65 
	dstellate[i][0].soma.ghbar_rm=0.000427944
	dstellate[i][0].soma.gkltbar_klt=0.0163897
}

param.w.x[lsr][tv] = 0.0021707
param.w.x[hsr][tv] = 0.0006168

param.w.x[glg][ds]	= 0.000532	
param.w.x[hsr][ds]	= 0.00127  
param.w.x[lsr][ds]	= 0.00309  
param.w.x[tv][ds]	= 0.00  
param.w.x[ds][tv]	= 0.0018  
reset_weights()



//QuickRun()
//spl=50
//sprint(fileroot,"%s_spl50",origfileroot)
//param.w.x[hsr][tv]=-0.0002
//param.w.x[lsr][tv]*=2
objref origpvec
//set_pvec()
//origpvec = pvec.c



//TV_BFtone()
//level=new Vector(20)
//level.indgen().mul(3).add(20) //20:3:60
//Ratelevel()
//TV_Noise()
//level=new Vector(20)
//level.indgen().mul(2).add(50) //50:2:88
//Ratelevel()

// Target RL data
objref target_rate_level[4],fitgr, tmpRL[8]
fitgr = new Graph()

error1=0
error2=0
error3=0
error4=0

func TV_RateLevel_err(){local jj,pp,xtime
    xtime=startsw()
    //check for bad values
    for pp=0,NPARAMS-1 {
		if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
			return 1e9
		}
    }
	//print variables
	print "TV_RateLevel_err ", $1 
    for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp]) }
	//Set the parameters (see parameters_TV_Notch.hoc)
	for pp=0,NPARAMS-1 {
		sprint(cmd,"%s = %g * %g ",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
		execute1(cmd)
    }
	//Rearrange synapses is using weight parameters
	reset_weights()
	for i = 0, ds2tvGLYlist.count-1 if(ds2tvGLYlist.object(i).postcell() == tuberculoventral[0][1]) print ds2tvGLYlist.object(i).weight=0
	TV_BFtone()
	level=new Vector(10)
	level.indgen().mul(3).add(20) //20:3:60
	Ratelevel()
	target_rate_level[0] = set_target_rate_level(SpirouFig8B_Control_Tone)
	error1 = sqrt(tvrate[0].meansqerr(target_rate_level))
	target_rate_level[1] = set_target_rate_level(SpirouFig8B_wStr_Tone)
	error2 = sqrt(tvrate[1].meansqerr(target_rate_level))
	tmpRL[0] = 	tvrate[0].c
	tmpRL[1] = 	tvrate[1].c
	tmpRL[2] = 	level.c
	tmpRL[3] =  dsrate[50].c
	tmpRL[4] =  grate[50].c
	tmpRL[5] =  hsrrate[50].c
	tmpRL[6] =  lsrrate[50].c
	
	save_rate_level()	
	
	TV_Noise()
	level=new Vector(10)
	level.indgen().mul(5).add(50)
	Ratelevel()
	target_rate_level[2] =set_target_rate_level(SpirouFig8B_Control_Noise)
	error3 = sqrt(tvrate[0].meansqerr(target_rate_level[2]))
	target_rate_level[3] =set_target_rate_level(SpirouFig8B_wStr_Noise)
	error4 = sqrt(tvrate[1].meansqerr(target_rate_level[3]))
	save_rate_level()	
	//Plot the results
	 if(object_id(fitgr)==0) fitgr = new Graph()
	 fitgr.erase_all()
     tmpRL[0].plot(fitgr,tmpRL[2],1,2)
     tmpRL[1].plot(fitgr,tmpRL[2],2,2)
     tvrate[0].plot(fitgr,level,1,2)
     tvrate[1].plot(fitgr,level,2,2)
     target_rate_level[0].plot(fitgr,tmpRL[2],1,1)
     target_rate_level[1].plot(fitgr,tmpRL[2],2,1)
     target_rate_level[2].plot(fitgr,level,1,1)
     target_rate_level[3].plot(fitgr,level,2,1)

     sprint(grlbl,"Error1 = %g", error1)
     fitgr.label(0.05,0.85,grlbl)
	 sprint(grlbl,"Error2 = %g", error2)
	 fitgr.label(0.05,0.75,grlbl)
	 sprint(grlbl,"Error3 = %g", error3)
	 fitgr.label(0.05,0.65,grlbl)
	 sprint(grlbl,"Error4 = %g", error4)
     fitgr.label(0.05,0.55,grlbl)
	 
	 for jj=0,NPARAMS-1{
		sprint(grlbl,"%s = %g", pvec_name.object(jj).s,pvec.x[jj])
		fitgr.label(0.65,0.45-0.05*jj,grlbl)
    }
	fitgr.exec_menu("View = plot")	
	doNotify()
	
	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
    }
	file.printf("%g\n",error1+error2+error3+error4)
	file.close()
	
	print "TV_RateLevel_err complete. Error ", error1+error2+error3+error4, " time (sec)", startsw() - xtime
	
    return error1+error2+error3+error4
}


func TV_RateLevel_err2(){local jj,pp,xtime
    xtime=startsw()
    //check for bad values
    for pp=0,NPARAMS-1 {
		if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1])) {
			return 1e9
		}
    }
	//print variables
	print "TV_RateLevel_err ", $1 
    for pp=0,NPARAMS-1 { printf("%s = %g * %g",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp]) }
	//Set the parameters (see parameters_TV_Notch.hoc)
	for pp=0,NPARAMS-1 {
		sprint(cmd,"%s = %g * %g ",pvec_name.object(pp).s,$&2[pp],pvec_factor.x[pp])
		execute1(cmd)
    }
	//Rearrange synapses is using weight parameters
	create_connect_TV(fileroot)
	reset_weights()
	for i = 0, ds2tvGLYlist.count-1 if(ds2tvGLYlist.object(i).postcell() == tuberculoventral[0][1]) print ds2tvGLYlist.object(i).weight=0
	TV_BFtone()
	level=new Vector(3)
	level.indgen().mul(15).add(20) //20:3:60
	Ratelevel()
	target_rate_level[0] = set_target_rate_level(SpirouFig8B_Control_Tone)
	error1 = sqrt(tvrate[0].meansqerr(target_rate_level))
	target_rate_level[1] = set_target_rate_level(SpirouFig8B_wStr_Tone)
	error2 = sqrt(tvrate[1].meansqerr(target_rate_level))
	tmpRL[0] = 	tvrate[0].c
	tmpRL[1] = 	tvrate[1].c
	tmpRL[2] = 	level.c
	tmpRL[3] =  dsrate[50].c
	tmpRL[4] =  grate[50].c
	tmpRL[5] =  hsrrate[50].c
	tmpRL[6] =  lsrrate[50].c
	
	save_rate_level()	
	
	TV_Noise()
	level=new Vector(3)
	level.indgen().mul(20).add(50)
	Ratelevel()
	target_rate_level[2] =set_target_rate_level(SpirouFig8B_Control_Noise)
	error3 = sqrt(tvrate[0].meansqerr(target_rate_level[2]))
	target_rate_level[3] =set_target_rate_level(SpirouFig8B_wStr_Noise)
	error4 = sqrt(tvrate[1].meansqerr(target_rate_level[3]))
	save_rate_level()	
	//Plot the results
	 if(object_id(fitgr)==0) fitgr = new Graph()
	 fitgr.erase_all()
     tmpRL[0].plot(fitgr,tmpRL[2],1,2)
     tmpRL[1].plot(fitgr,tmpRL[2],2,2)
     tvrate[0].plot(fitgr,level,1,2)
     tvrate[1].plot(fitgr,level,2,2)
     target_rate_level[0].plot(fitgr,tmpRL[2],1,1)
     target_rate_level[1].plot(fitgr,tmpRL[2],2,1)
     target_rate_level[2].plot(fitgr,level,1,1)
     target_rate_level[3].plot(fitgr,level,2,1)

     sprint(grlbl,"Error1 = %g", error1)
     fitgr.label(0.05,0.85,grlbl)
	 sprint(grlbl,"Error2 = %g", error2)
	 fitgr.label(0.05,0.75,grlbl)
	 sprint(grlbl,"Error3 = %g", error3)
	 fitgr.label(0.05,0.65,grlbl)
	 sprint(grlbl,"Error4 = %g", error4)
     fitgr.label(0.05,0.55,grlbl)
	 
	 for jj=0,NPARAMS-1{
		sprint(grlbl,"%s = %g", pvec_name.object(jj).s,pvec.x[jj])
		fitgr.label(0.65,0.45-0.05*jj,grlbl)
    }
	fitgr.exec_menu("View = plot")	
	doNotify()
	
	sprint(fname,"%s/error_out.dat",fileroot)
	file.aopen(fname)
	for pp=0,NPARAMS-1 {
		file.printf("%g\t",$&2[pp]*pvec_factor.x[pp])
    }
	file.printf("%g\n",error1+error2+error3+error4)
	file.close()
	
	print "TV_RateLevel_err complete. Error ", error1+error2+error3+error4, " time (sec)", startsw() - xtime
	
    return error1+error2+error3+error4
}


proc QuickRun(){
	set_pvec()
    pvec.printf
    print TV_RateLevel_err2(0,&pvec.x[0])
}

proc runprax2(){
    sprint(cmd,"mkdir -p %s",fileroot)
    system(cmd)
    sprint(cmd,"touch %s/error_out.dat",fileroot)
    system(cmd)
    attr_praxis(0.01, 0.1, 3)
    fit_praxis(NPARAMS,"TV_RateLevel_err",&pvec.x[0])
}

proc runprax(){
	attr_praxis(0.001, 0.001, 3)
	fit_praxis(NPARAMS,"TV_RateLevel_err2",&pvec.x[0])
}



proc printprax2(){local pp,ii,pp2,error
	//Output model data with best parameters
	
    sprint(cmd,"mkdir -p %s",fileroot)
    system(cmd)
   	    
	print error=TV_RateLevel_err(0,&pvec.x[0])
	system("date",datestr)
    sprint(fname,"%s/%s.Fit.dat",fileroot,origfileroot)
	file.wopen(fname)
	if (file.isopen()){
		file.printf("# %s Optimisation\n",fileroot)
		file.printf("# %s \n",datestr)
		for pp=0,NPARAMS-1 {
			file.printf("#%s = %g\t[%g,%g]\n",pvec_name.object(pp).s,pvec.x[pp]*pvec_factor.x[pp],pvec_ranges.x[pp][0],pvec_ranges.x[pp][1])
		}
		file.printf("# RL Error = %g\n", error1)
		file.printf("# RL without DS Error	 = %g\n", error2)
		file.printf("# NRL Error = %g\n", error3)
		file.printf("# NRL without DS Error = %g\n", error4)
		file.printf("# Final error = %g\n",error)

		
		/*
		file.printf("# Principle axis matrix\n")
		for pp=0,NPARAMS-1 {
			pval[pp] = new Vector(NPARAMS)
			pval_praxis(pp,&pval[pp].x[0])
			
			file.printf("#\t")
			if (pval[pp].size == NPARAMS){
				for pp2=0,NPARAMS-1 file.printf("%g\t",pval[pp].x[pp2])
			}
			file.printf("\n")
		}
		*/
		file.printf("# Level, TV Model, TV Model without DS, DS, GLG, HSR, LSR (sp/s)\n")
		for i=0,level.size-1{
			file.printf("%d\t%g\t%g\t%g\t%g\t%g\t%g\n",level.x[i],\
			tvrate[0].x[i],tvrate[1].x[i],\
			dsrate[50].x[i],grate[50].x[i],\
			hsrrate[50].x[i],lsrrate[50].x[i])
		}
		file.printf("\n\n",error)
		for i=0,tmpRL[2].size-1{
			file.printf("%d\t%g\t%g\t%g\t%g\t%g\t%g\n",tmpRL[2].x[i],\
			tmpRL[0].x[i],tmpRL[1].x[i],\
			tmpRL[3].x[i],tmpRL[4].x[i],\
			tmpRL[5].x[i],tmpRL[6].x[i])
		}		
		file.printf("#Other values \n")
		// file.printf("#spl = %g\n",spl)
		// file.printf("#  halfoct_compress = %g\n",  halfoct_compress)
		// file.printf("#  halfoct_shift = %g\n",  halfoct_shift)
		// file.printf("# oct_compress = %g\n", oct_compress)
		// file.printf("# oct_shift  = %g\n", oct_shift )
		// file.printf("# centrepoint = %g\n",centrepoint)
		file.printf("# TV erev = %g\n",tuberculoventral[0][0].soma.erev_rm)
		param.printparams(file,"#") //let Network Parameters print the struct
		file.close()
	
	}
	
		//Write parameters to general optimisation file
	sprint(fname,"%s/pvec_%s.hoc",fileroot,origfileroot)
	file.aopen(fname)
	file.printf(" // %s  \n",datestr)
	for pp=0,NPARAMS-1 {
		file.printf("%s = %g\n",pvec_name.object(pp).s,pvec.x[pp]*pvec_factor.x[pp])
    }
	file.close()
}


dt=0.1
//QuickRun()


//xopen("TV_RateLevel/pvec_TV_RateLevel.hoc")
set_pvec()
reps=10
runprax()
runprax()
//reps=5
runprax2()

reps=50
printprax2()



proc Rerun_ANmodel(){
	stimtype=6
	for (spl=50;spl<=100;spl+=5){
RefreshParameters() 
RefreshParameters()
ANFilterBankRun()
SaveANFilterBank2File()
for i=0,nchannels-1 golgi[i][0].SetRate2()
SaveGolgiFilterBank2File()
}
}
