
/*
 *   TV_Notch.hoc
 *
 */
load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")

xopen("mathslib.hoc")         // mathematical procedures
xopen("Params.hoc")           // default parameters
xopen("Utilities.hoc")
xopen("NetworkParameters.hoc")
xopen("AuditoryNerve.hoc")
xopen("par_CNcell.tem")      // CN cell template
xopen("parameters_TV_Notch.hoc")     //This model's parameters
xopen("CochlearNucleus.hoc")         // model set-up
  //--- Setup Auditory and CN Stellate model
  create_cells()
  connect_cells(fileroot)
  connect_CNcells(fileroot)
//Previous optimisation parameters
xopen("pvec_Golgi_RateLevel.hoc")
xopen("pvec_DS_ClickRecovery.hoc")
  reset_weights()
  reset_DS_ClickRecovery()
  
//Setup this experiment
xopen("par_experiment_TV_Notch.hoc")


proc SetRates(){
  an.SetRates()
  for i=0,99 golgi[i][0].SetRate2() //enable H and L ANFs in golgi cells
}


proc GenSpikes2(){local i,j,count
    startsw()
    for i=0,nchannels-1 {for j=0,HSRsperchannel-1 {an.HSR[i][j].SGfast2(1)}}
    for i=0,nchannels-1 {for j=0,HSRsperchannel-1 count+=an.HSRspiketimes[i][j].size}
    // if (count/(nchannels*HSRsperchannel) > 10) system("sleep 0.5")
    for i=0,nchannels-1 {for j=0,LSRsperchannel-1 an.LSR[i][j].SGfast2(1)}
    for i=0,nchannels-1 {golgi[i][0].s.SGfast2(1)}
    print "GenSpikes time:", stopsw()
}



  xopen("cngui.hoc")


proc SaveMultiRun(){
  sprint(cmd,"TV_notch/CN_rateplace_%goct_spl%d.eps",notchwidth,spl)
    CNrategr.printfile(cmd)
    sprint(cmd,"TV_notch/AN_rateplace_%goct_spl%d.eps",notchwidth,spl)
    ANFgr[1].printfile(cmd)
    sprint(cmd,"TV_notch/CN_rateplace_%goct.tv.dat",notchwidth)
    { file.aopen(cmd) CNrate[tv].printf(file) file.close() }
  sprint(cmd,"TV_notch/CN_rateplace_%goct.ds.dat",notchwidth)
    { file.aopen(cmd) CNrate[ds].printf(file) file.close() }
  sprint(cmd,"TV_notch/CN_rateplace_%goct.glg.dat",notchwidth)
    { file.aopen(cmd) CNrate[glg].printf(file) file.close() }
  sprint(cmd,"TV_notch/AN_rateplace_%goct.hsr.dat",notchwidth)
    { file.aopen(cmd) ANFrate[0].printf(file) file.close() }
  sprint(cmd,"TV_notch/AN_rateplace_%goct.lsr.dat",notchwidth)
    { file.aopen(cmd) ANFrate[1].printf(file) file.close() }
}



  //////////Default Parameters for TV_Notch///////////////
  ANsoundspath="../../sounds"
  cfhi     =48000
  cflo     =200

  tstop = 100       //ms
  dur      = 0.095    //duration of stim (seconds)
  spl      = 70     //dB SPL
  stimdelay= 0.01   //sec
  stimtype = 12     //Notch
  reps     = 50     //
  ANmodel  = 6      //Zilany Bruce model version 3
  species  = 1      //Cat
  nrep     = 1        //nrep is number of reps of stimulus
  stopband = 6.5 //kHz
  notchwidth = 1
  srate
  ANFBgr = new Graph()
  usesavedfilterbanks=1
  srate=100000
  stimtdres=1/srate
  sg_rate=50000
  sg_tdres=1/sg_rate
 // RefreshCF()
 // GetAudiogramData()
 // RefreshParameters()
 // ANFilterBankRun()

  //wavefile="./TV_notch/Notch-sb10-0.5oct.dat"
  //file.ropen("./TV_notch/Notch-sb10-1oct.dat")
  //Readfile(stim,file)
  //		spl=85
  //		RescaleStim(spl,0,stim.size-1)
  //		ANFilterBankRun()   //Build the filterbank
  //		CheckFilterbank()
  //		SetRates()      //Allocate filterbanks to ANFs
  //ShowInputGraphs()
  //ShowGolgiGraphs()
  //GenSpikes()
  //ANSpikes()

  //xopen("TV_Notch.ses")		
 
  /*  for (spl=15;spl<=100;spl+=5){
    RefreshParameters()
    ANFilterBankRun()   //Build the filterbank
    CheckFilterbank()
    SetRates()
    multi_run()
    ANSpikes()
    SaveMultiRun()
  }

  for (spl=15;spl<=100;spl+=5){
    RefreshParameters()
      ANFilterBankRun()   //Build the filterbank
      CheckFilterbank()
      SetRates()
      multi_run()
      ANSpikes()
      SaveMultiRun()
      }
  */
//xopen("cngui.hoc")





/*

//ShowGolgiGraphs()

//TV Optimisation
objref gr,target_notch, dslist, fvec,dvec,ivec,weighting

objref gpstlist, grate[nchannels],anrate[nchannels],rate_level_graph
gr = new Graph()

target_notch = new Vector()
//TODO Setup target_notch

target_notch.plot(gr,2,2)
gr.exec_menu("View = plot")



objref g, dvec, fvec,ivec,gg
gg = new Graph()
g = new Graph()
g.size(0,3,0,3)






// Simplex Method Optimisation function
//D-stellate Click train PSTH   (Backoff et al. 1997)

a1 =   param.w.x[glg][ds]
a2  =     param.w.x[hsr][ds]
// a3 =     param.n.x[hsr][ds]

objref errorvec, DSvec
func fun() {local f
objref errorvec, DSvec
DSvec  = new Vector()
{
g.line($2, $3)
g.flush()
doNotify()
print $1, $2 , $3
}
//Modify Variables
param.w.x[glg][ds] = $2
param.w.x[hsr][ds] = $3
param.w.x[lsr][ds] = $3
//param.n.x[hsr][ds] = $4
{reset_weights()}
for j=0, reps-1{
print j
GenSpikes()
run()
DSvec.append(dstellate[50][0].spiketimes)
//print startsw()-x, "secs"
}
DSvec = DSvec.histogram(0,tstop,0.1)

objref errorvec
errorvec = new Vector()
//Find the mean number of spikes in the first click
maxrate = (DSvec.sum(240,260) + DSvec.sum(740,760)+ DSvec.sum(1340,1360))/3
//Calc ratio of number of spikes in second clcik relative to mean first click
errorvec.append( DSvec.sum(260,280) / maxrate )
errorvec.append( DSvec.sum(780,800) / maxrate )
errorvec.append( DSvec.sum(1420,1440) / maxrate )
errorvec.plot(gr,3,3)
print maxrate
errorvec.printf
return errorvec.meansqerr(targetclickrecovery)
}


ivec = new Vector(1,0)
fvec = new Vector(1,0)
dvec = new Vector(1,0)
error=0
objref file, DShist
file = new File()
DShist = new Vector()


proc RunFit(){
g.beginline()
error = dvec.fit(fvec, "fun", ivec, &a1, &a2)
print a1, a2, error
g.flush()
g.exec_menu("View = plot")
//fvec.plot(Graph[0],ivec,1,1)
//Output
file.wopen("TV_Notch.out.dat")
file.printf("# TV_Notch data\n")
file.printf("# weight GLG->DS =%.2f\n",a1)
file.printf("# weight ANF->DS =%.2f\n",a2)
file.printf("# final error=%.2f\n",error)
file.printf("# Index\tTarget Rate (normalised)\t Output\n")
for i=0,2 { file.printf("%d\t%.3f\t%.3f\n",i,targetclickrecovery.x[i],errorvec.x[i]) }
file.close()
}

//
// RunFit()
//


// Praxis method
a=0
print "Setup parameters"
NPARAMS=5
objref pvec,fvec,DSvec,DShist,pvec_ranges,Gvec,Ghist
pvec = new Vector(NPARAMS)
//pvec contains the parameters to be fitted
//Initial values
pvec.x[0]= 0.00081
pvec.x[1]= 0.00201
pvec.x[2]= 0.00206
pvec.x[3]= 0.002
pvec.x[4]= 0.0008

//pvec.x[2]= param.w.x[lsr][ds]
//pvec.x[3]=

//pvec_ranges  (min,max) pairs for each param
pvec_ranges= new Matrix(NPARAMS,2)
//min
for i=0,NPARAMS-1 pvec_ranges.x[i][0]= 0.00001
//max
for i=0,NPARAMS-1 pvec_ranges.x[i][1]= 0.005

func err() {local jj,pp
DSvec = new Vector()
Gvec = new Vector()
param.w.x[glg][ds] = $&2[0]
param.w.x[hsr][ds] = $&2[1]
param.w.x[lsr][ds] = $&2[2] //param.w.x[hsr][ds]
dstellate[50][0].GABAA.tau2 = $&2[3]*10000
dstellate[50][0].soma.gleak_rm = $&2[4]
print $&2[0], $&2[1], $&2[2], $&2[3],$&2[4] //param.w.x[glg][ds], param.w.x[hsr][ds]

// check for bad values
for pp=0,NPARAMS-1 {
if ($&2[pp] <= pvec_ranges.x[pp][0] || $&2[pp] > pvec_ranges.x[pp][1]){
return 1e9
}
}
//param.n.x[hsr][ds] = $&2[2]
reset_weights()
for jj=0, reps-1{
//print jj
GenSpikes2()
run()
DSvec.append(dstellate[50][0].spiketimes)
Gvec.append(golgi[50][0].spiketimes)
//print startsw()-x, "secs"
}
DShist = DSvec.histogram(0,tstop,0.1)
Ghist = Gvec.histogram(0,tstop,0.1)
DShist.plot(g,0.1)
g.exec_menu("View = plot")
Ghist.plot(gg,0.1)
gg.exec_menu("View = plot")
doNotify()
objref errorvec
errorvec = new Vector()
//Find the mean number of spikes in the first click
//  maxrate = (DShist.sum(240,260) + DShist.sum(740,760)+ DShist.sum(1340,1360))/3
//     if (maxrate < 1) return 1e10
//Calc ratio of number of spikes in second clcik relative to mean first click

for (i=0;i<clicktimes.size;i=i+1){
errorvec.append(DShist.sum(clicktimes.x[i]*10000/srate+40,clicktimes.x[i]*10000/srate+60))
}
//clicktimes.append(10,26,80,82,150,158,210,214,280,283).mul(srate/1000)
errorvec.append(DShist.sum(clicktimes.x[1]*10000/srate+60,clicktimes.x[2]*10000/srate+40))
errorvec.append(DShist.sum(clicktimes.x[3]*10000/srate+60,clicktimes.x[4]*10000/srate+40))
errorvec.append(DShist.sum(clicktimes.x[5]*10000/srate+80,clicktimes.x[6]*10000/srate+40))
errorvec.append(DShist.sum(clicktimes.x[7]*10000/srate+80,clicktimes.x[8]*10000/srate+40))

errorvec.mul(1/reps)
print a=errorvec.meansqerr(targetclickrecovery,wclick)
gr.erase_all()
sprint(grlbl,"Error = %g", a)
gr.label(0.65,0.85,grlbl)
sprint(grlbl,"weight GLG->DS = %g", pvec.x[0])
gr.label(0.65,0.75,grlbl)
sprint(grlbl,"weight HSR->DS = %g", pvec.x[1])
gr.label(0.65,0.65,grlbl)
sprint(grlbl,"weight LSR->DS = %g", pvec.x[2])
gr.label(0.65,0.55,grlbl)
sprint(grlbl,"GABA decay tau = %g ", pvec.x[3]*10000)
gr.label(0.65,0.45,grlbl)
sprint(grlbl,"DS gleak = %g ", pvec.x[4])
gr.label(0.65,0.35,grlbl)
targetclickrecovery.plot(gr,2,1)
	    errorvec.plot(gr,3,2)
	    doNotify()
	    if(file.isopen())  file.close()
				 file.aopen("TV_Notch/praxis.dat")
				 file.printf("%g\t%g\t%g\t%g\t%g\t%g\n",$&2[0],$&2[1],$&2[2] ,$&2[3]*10000,$&2[4] ,a)
				 file.close()
				 //  print maxrate
				 errorvec.printf

				 return a

				 }

//objref dstellate[nchannels][1]
//dstellate[50][0] = new CNcell(2,cf.x[50],50)
  connect_cells(fileroot)
  //tstop=300
  pvec.printf
  // print err(0,&pvec.x[0])
  proc runprax(){
    attr_praxis(0.0001, 0.001, 3)
      fit_praxis(NPARAMS,"err",&pvec.x[0])
      }
error=0
    strdef datestr,grlbl
    objref ivec
    ivec= new Vector()
    ivec.append(3,9,7,5,1,2,8,6,4,0,10,11,12,13)
    proc runprax2(){
  //Output model data with best parameters
  print error=err(0,&pvec.x[0])
  system("date",datestr)
  sprint(fname,"%s/%s.Fit.dat",fileroot,fileroot)
  file.wopen(fname)
  if (file.isopen()){
    file.printf("# %s Optimisation\n",fileroot)
    file.printf("# %s \n",datestr)
    for pp=0,NPARAMS-1 {
	file.printf("#%s = %g\t[%g,%g]\n",pvec_name.object(pp).s,pvec.x[pp],pvec_ranges.x[pp][0],pvec_ranges.x[pp][1])
      }
    file.printf("# final error=%f\n",error)
    file.printf("# unweighted error=%f\n",errorvec.meansqerr(targetclickrecovery)) file.printf("#  %.3f\n",errorvec.x[ii]) }
}
  file.close()
  sprint(fname,"(cd %s; gnuplot %s_ExpData.gnu)",fileroot,fileroot)
  system(cmd)
  //Write parameters to general optimisation file
  sprint(fname,"pvec_%s.hoc",fileroot)
  file.aopen(fname)
  file.printf(" //  %s  \n",datestr)
  for pp=0,NPARAMS-1 {
      file.printf("%s = %g\n",pvec_name.object(pp).s,pvec.x[pp])
    }
    file.close()
    }
for iprax=0,20 {
    runprax()
    // Default Output Plot
    sprint(grlbl, "TV_Notch/TV_Notch_Example%d.eps",iprax)
    gr.printfile(grlbl)
    g.printfile("TV_Notch/TV_Notch_DSpsth.eps")
    gg.printfile("TV_Notch/TV_Notch_Gpsth.eps")
    g.erase_all()
    gg.erase_all()
  }
//runprax()
//runprax()
  runprax2()
  */




