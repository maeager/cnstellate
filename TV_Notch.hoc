
/*
 *   TV_Notch.hoc
 *
 */
load_file("nrngui.hoc")
//load_file("par_netpar.hoc")
//load_file("par_init.hoc")

xopen("mathslib.hoc")         // mathematical procedures
xopen("Params.hoc")           // default parameters
xopen("Utilities.hoc")
xopen("NetworkParameters.hoc")
xopen("AuditoryNerve.hoc")
xopen("par_CNcell.tem")      // CN cell template
xopen("parameters_TV_Notch.hoc")     //This model's parameters
xopen("CochlearNucleus.hoc")         // model set-up
  //--- Setup Auditory and CN Stellate model
  create_cells()
  connect_cells(fileroot)
  connect_CNcells(fileroot)
//Previous optimisation parameters
xopen("pvec_Golgi_RateLevel.hoc")
xopen("pvec_DS_ClickRecovery.hoc")
  reset_weights()
  reset_DS_ClickRecovery()
  
//Setup this experiment
xopen("par_experiment_TV_Notch.hoc")


  xopen("cngui.hoc")

proc SetRates(){
  an.SetRates()
    // if (RetrieveGolgiFilterBank() == 0) { 
     for i=0,99 golgi[i][0].SetRate2() //enable H and L ANFs in golgi cells
	     //    SaveGolgiFilterBank2File()
	     //   }
 
}

proc GenSpikes2(){local i,j,count
    startsw()
    for i=0,nchannels-1 {for j=0,HSRsperchannel-1 {an.HSR[i][j].SGfast2(1)}}
  // for i=0,nchannels-1 {for j=0,HSRsperchannel-1 count+=an.HSRspiketimes[i][j].size}
    // if (count/(nchannels*HSRsperchannel) > 10) system("sleep 0.5")
    for i=0,nchannels-1 {for j=0,LSRsperchannel-1 an.LSR[i][j].SGfast2(1)}
    for i=0,nchannels-1 {golgi[i][0].s.SGfast2(1)}
    print "GenSpikes time:", stopsw()
}
proc multi_run(){local irep
    startsw()
    ClearSpikes()
    for irep=0,reps-1{
	GenSpikes2()
	print irep
	run()
        SaveSpikes()
    }
    print "Multi_run time:", stopsw()
    }

proc CNSpikes2(){local i, icf
    objref CNgr[4],CNspks[nchannels][4],CNhist[nchannels][4],CNrate[4],CNrategr
    for i=0,3 {
	CNgr[i] = new Graph()
	CNrate[i] = new Vector()
    }
    CNhist = new Graph()
    CNrategr = new Graph()
    for icf=0 ,  nchannels-1{
	CNspks[icf][tv] = new Vector()
	CNspks[icf][ds] = new Vector()
	CNspks[icf][glg] = new Vector()	
	
	if (nDSperchannel > 0){ 
	  CNspks[icf][ds] = dstellate[icf][0].spikes.histogram(0,tstop,0.1)
	  
	}
	if (nTVperchannel > 0){
	  CNspks[icf][tv] = tuberculoventral[icf][0].spikes.histogram(0,tstop,0.1)
	}
	if (nGperchannel > 0){
	  CNspks[icf][glg] = golgi[icf][0].spikes.histogram(0,tstop,0.1) 
	}
	for i=1,3{
	    if (CNspks[icf][i].size() > 0 ) {
	      CNrate[i].append(CNspks[icf][i].mean() / (reps*0.1/1000))
	    }
	  }
      }
    for i=1,3{
	CNrate[i].plot(CNrategr,1,i,1)
      }
   
    CNrategr.label(0, 0,"TV",1,1,-25,-14,tv)
    CNrategr.label(0, 0,"DS",1,1,-25,-13,ds)
    CNrategr.label(0, 0,"GLG",1,1,-25,-12,glg)
    CNrategr.label(0.3, 0.95,"Rate-Place Representation")
    CNrategr.exec_menu("View = plot")
}


  //////////Default Parameters for TV_Notch///////////////
  ANsoundspath = "../../sounds"
  cfhi     = 48000
  cflo     = 200
  ramplngth = 0.002
  tstop    = 100    // ms
  dur      = 0.048  // duration of stim (seconds)
  spl      = 90     // dB SPL
  stimdelay= 0.01   // sec
  stimtype = 12     // Notch
  reps     = 50     //
  ANmodel  = 6      // Zilany Bruce model version 3
  species  = 1      // Cat

  stopband = 6      // kHz
  notchwidth = 1
 centrepoint=stopband
 GenNotchResponsePlots()
  freq1_notch.mul(1000)

  ANFBgr = new Graph()
  usesavedfilterbanks=1
  srate     = 100000
  stimtdres = 1/srate
  sg_rate   = 50000
  sg_tdres  = 1/sg_rate
 RefreshCF()
 GetAudiogramData()
 RefreshParameters()
 ANFilterBankRun()
CheckFilterbank()
 SetRates()
  
  //reps=20 
  //multi_run()
  //CNSpikes2()

  objref fitgr,gg
  //fitgr = new Graph()
  //expected_notch[1].div(expected_notch[1].max()).plot(fitgr,freq1_notch,4,1)
  //CNrate[tv].div(CNrate[tv].max()).plot(fitgr,cf,3,1)
 
  //		RescaleStim(spl,0,stim.size-1)
  //		ANFilterBankRun()   //Build the filterbank
  //		CheckFilterbank()
  //		SetRates()      //Allocate filterbanks to ANFs
  //ShowInputGraphs()
  //ShowGolgiGraphs()
  //GenSpikes()
  //ANSpikes()

  //xopen("TV_Notch.ses")		
 
  /*  for (spl=15;spl<=100;spl+=5){
    RefreshParameters()
    ANFilterBankRun()   //Build the filterbank
    CheckFilterbank()
    SetRates()
    multi_run()
    ANSpikes()
    SaveMultiRun()
  }

  for (spl=15;spl<=100;spl+=5){
    RefreshParameters()
      ANFilterBankRun()   //Build the filterbank
      CheckFilterbank()
      SetRates()
      multi_run()
      ANSpikes()
      SaveMultiRun()
      }
  */
//xopen("cngui.hoc")

//ShowGolgiGraphs()

//TV Optimisation
  objref gr,target_notch, dslist, fvec,dvec,ivec,weighting,errorvec
objref anrate[nchannels],rate_level_graph
gr = new Graph()


proc ConnectDS2TV(){local channel,target,i,sourcechannel,source
 for channel = 0, nchannels-1{
  for target = 0, nTVperchannel-1 {
   for i=0, param.n.getval(ds,tv)-1{
    //Choose source channel
    sourcechannel = random.normal(channel,param.bw.getval(ds,tv)/2)
    if ((sourcechannel - int(sourcechannel)) > 0.5 ){
        sourcechannel = 1+int(sourcechannel)
    } else { sourcechannel = int(sourcechannel) }
    if (sourcechannel <=0 ) sourcechannel=0
    if (sourcechannel > nchannels-1 ) sourcechannel=nchannels-1
    //Choose random source from available cells
    source = random.discunif(0,nDSperchannel-1)
 // print "DS[",sourcechannel,"][",source,"] connected to "TV[",channel,"][",target,"]"
		sprint(cmd, "dstellate[%d][%d].soma ds2tvGLYlist.append( new NetCon(&v(0.5), tuberculoventral[%d][%d].GlyR, thresh,param.delay.getval(ds,tv), param.w.getval(ds,tv)))",sourcechannel,source,channel,target)
        execute1(cmd)
 
   }
  }
        p = 100*(channel)/(nchannels)
    printf("\rDS->TV=== %3d%% ===",p)
    flushf()
    doNotify() // Although this slows down cell creation, the
               // process is so long that we have to allow the
               // user to quit during the creation.
 }
  printf("\n")
}


//
// Fitness/error function
//


objref tempcf,indcf,errorvec

func TV_Notch_err( ) {local jj,pp,xtime

// check for bad values
    for pp=0,NPARAMS-1 {
	if (($&2[pp] <= pvec_ranges.x[pp][0]) || ($&2[pp] > pvec_ranges.x[pp][1]))   return 1e9
    }
  //Terminate DS2TV connections
  ds2tvGLYlist.remove_all()
  
    //Set the parameters (see parameters_TV_Notch.hoc)
 set_params()
    //Connect DS to TV synapses
  ConnectDS2TV()
  reset_weights()
  ClearSpikes()
xtime=startsw()
for jj=0, reps-1{
    GenSpikes2()
printf("%d", jj)
    run()
    SaveSpikes()
    print startsw()-xtime, "secs"
}
  //Ananlyse spikes
CNSpikes2()


  objref fitgr
 fitgr = new Graph()
 expected_notch[1].div(expected_notch[1].max()).plot(fitgr,freq1_notch,4,1)
 CNrate[tv].div(CNrate[tv].max()).plot(fitgr,cf,3,1)
fitgr.exec_menu("View = plot")

  objref errorvec,tempcf,indcf

  indcf = new Vector()
  indcf.indvwhere(cf,"()",freq1_notch.x[0],freq1_notch.x[freq1_notch.size()-1])
  tempcf = cf.c(indcf.x[0]-1,indcf.x[indcf.size()-1]+1)

errorvec = new Vector()
errorvec.interpolate(CNrate[tv],tempcf, freq1_notch)


print a=errorvec.meansqerr(expected_notch[1])
gr.erase_all()
  errorvec.plot(gr,freq1_notch,1,1)
  expected_notch[1].plot(gr,freq1_notch,2,2)
sprint(grlbl,"Error = %g", a)
gr.label(0.65,0.85,grlbl)
for jj=0,NPARAMS-1{
sprint(grlbl,"%s = %g", pvec_name.x[jj],pvec.x[jj])
gr.label(0.65,0.75-0.05*jj,grlbl)
}
doNotify()
return a
}

  //tstop=300
proc QuickRun(){
  pvec.printf
  print TV_Notch_err(0,&pvec.x[0])
    }

 proc runprax(){
    attr_praxis(0.0001, 0.001, 3)
    fit_praxis(NPARAMS,"TV_Notch_err",&pvec.x[0])
      }

error=0
    strdef datestr,grlbl
    objref ivec
    ivec= new Vector()
    ivec.append(3,9,7,5,1,2,8,6,4,0,10,11,12,13)
    /*
proc runprax2(){
  //Output model data with best parameters
  print error=err(0,&pvec.x[0])
  system("date",datestr)
  sprint(fname,"%s/%s.Fit.dat",fileroot,fileroot)
  file.wopen(fname)
  if (file.isopen()){
    file.printf("# %s Optimisation\n",fileroot)
    file.printf("# %s \n",datestr)
    for pp=0,NPARAMS-1 {
	file.printf("#%s = %g\t[%g,%g]\n",pvec_name.object(pp).s,pvec.x[pp],pvec_ranges.x[pp][0],pvec_ranges.x[pp][1])
      }
    file.printf("# final error=%f\n",error)
    file.printf("# unweighted error=%f\n",errorvec.meansqerr(targetclickrecovery)) file.printf("#  %.3f\n",errorvec.x[ii]) }

  file.close()
  sprint(fname,"(cd %s; gnuplot %s_ExpData.gnu)",fileroot,fileroot)
  system(cmd)
  //Write parameters to general optimisation file
  sprint(fname,"pvec_%s.hoc",fileroot)
  file.aopen(fname)
  file.printf(" //  %s  \n",datestr)
  for pp=0,NPARAMS-1 {
      file.printf("%s = %g\n",pvec_name.object(pp).s,pvec.x[pp])
    }
    file.close()
    
for iprax=0,20 {
    runprax()
    // Default Output Plot
    sprint(grlbl, "TV_notch/TV_Notch_Example%d.eps",iprax)
    gr.printfile(grlbl)
    g.printfile("TV_notch/TV_Notch_DSpsth.eps")
    //gg.printfile("TV_notch/TV_Notch_Gpsth.eps")
    g.erase_all()
    //gg.erase_all()
  }  
}
    */

//runprax()
//runprax()
//  runprax2()





